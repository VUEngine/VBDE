<!DOCTYPE html>
<html>
  <head>
    <title>Virtual Boy Specifications</title>
    <style type="text/css">

h1 {
    font-size:         24px;
    font-weight:       normal;
    background-color:  #cccccc;
    border: 1px solid  #cccccc;
    margin-bottom:     24px;
    page-break-before: always;
    padding-left: 8px;
}

body       { background-color: #ffffff; color: #000000; }
a:link     { color: #0033cc; }
a:active   { color: #0033cc; }
a:visited  { color: #0033cc; }

td {
    border: none;
    padding: 4px;
    width: 80px;
    text-align: center;
}

div.arg    { display: inline-block; width: 48px; font-style: italic; }
div.reset  { display: inline-block; width: 64px; }
table      { border: none; border-spacing: 0px; margin-left: 24px; }
td.ex      { width: 128px; }
td.exdef   { width: 150px; }
td.exhdr   { text-decoration: underline; }
.indent    { margin-left: 24px; }
pre, .mono { font-family: monospace; }
span.br    { page-break-before: always; }
@media print { .js { display: none } }

    </style>
    <script type="text/javascript">
function getChild(el, cname) { var x, nodez = el.childNodes; if (!nodez) return
null; for (x = 0; x < nodez.length; x++) if (nodez[x].localName == cname)
return nodez[x]; return null; } function changeColors() { var x, mark, el; el =
getChild(document.documentElement, "head"); if (!el) return; el = getChild(el,
"style"); if (!el) return; mark = el.innerHTML; x = mark.indexOf("/* Cutoff */"
); if (x > 0) el.innerHTML = mark.substring(0, x); else el.innerHTML = mark +
"/* Cutoff */\n\n@media screen { body { background-color: #000000; color:" +
" #ff0000; }\nh1 { background-color: #550000; border: 1px solid #550000; }\n" +
"a:link { color: #990000; }\na:visited { color: #aa0000; }\na:active  {" + 
"color: #990000; }\nb { text-decoration: underline; }}";}
    </script>
  </head>
  <body onload="if (location.search) changeColors();">

<h1 style="page-break-before: avoid;"><a name="contents">VB Sacred Tech Scroll
- Virtual Boy Specifications</a></h1>

<b>Virtual Boy Hadrware Specifications</b><br />
<a href="#cartridgesandromformat">Cartridges &amp; ROM Format</a><br />
<a href="#cpumemorymap">CPU Memory Map</a><br />
<a href="#virtualimageprocessorvip">Virtual Image Processor (VIP)</a><br />
<a href="#virtualsoundunitvsu">Virtual Sound Unit (VSU)</a><br />
<a href="#hardwarecontrolregisters">Hardware Control Registers</a><br />
<a href="#cpuv810familymicroprocessor">CPU V810 Family Microprocessor</a><br />
<a href="#systemreset">System Reset</a><br />
<a href="#credits">About VB Sacred Tech Scroll</a><br />

<script type="text/javascript">document.writeln("<span class=\"js\">" +
"<a href=\"javascript:changeColors();\">Change Colors</a><br /></span>");
</script>
<br />



<h1><a name="cartridgesandromformat">Cartridges &amp; ROM Format</a></h1>

Cartridges on Virtual Boy contain memory circuits for both ROM and WRAM, which
get mapped directly onto the system bus. The ROM data contains information
pertinent to running the program as well as some additional information about
the game provided by Nintendo.<br /><br />

<a name="formatcartridgememory"><b>Cartridge Memory</b></a><br /><br />

The CPU address space allows for up to 16 MB of both ROM and RAM on the
cartridge, for a maximum total of 32 MB of memory. Additionally, address space
is allocated for another 16 MB of cartridge expansion memory, though it was
never used in any commercial game.<br /><br />

ROM images must be at the very least no fewer than 1024 bytes in size, and the
number of bytes must be an integral power of 2. The implication is that in the
binary representation of the number of bytes in the image, only one bit will be
set and the rest will be zero. The addresses in the ROM memory range are masked
with <code>(rom_size - 1)</code>, effectively mirroring/duplicating the
contents of ROM across the entire 16 MB memory range. The same occurs for
cartridge RAM.<br /><br />

<i>Editor's Note: There is no information in the ROM image describing the
capacity of the RAM chip, though it is assumed the mirroring works the same
way. Emulators should support however much RAM games attempt to access, at
least until a de facto ROM file format standard with a header can be drafted
up.</i><br /><br />

RAM on Virtual Boy cartridges (if present) may be battery backed
(SRAM).<br /><br />

<a name="formatromformat"><b>ROM Format</b></a><br /><br />

Virtual Boy ROM images are directly used by the CPU as per the V810 family
specification. After all ROM mirroring and system address masking occurs, the
effective ROM data starting at address 0xFFFFFDE0 contains significant
information. In other words, the significant data inside a ROM file is located
at <code>(rom_size - 544)</code>.<br /><br />

<a name="formatvirtualboyromheader"><b>Virtual Boy ROM Header</b></a><br />
<pre class="indent">
  0xFFFFFDE0-0xFFFFFDF3   Game Title, Shift-JIS
  0xFFFFFDF4-0xFFFFFDF8   (Reserved, zero)
  0xFFFFFDF9-0xFFFFFDFA   Maker code, ASCII
  0xFFFFFDFB-0xFFFFFDFE   Game code, ASCII
  0xFFFFFDFF              Game version, 1.&lt;value>
</pre>

<a name="formatexceptionhandlers"><b>V810 Family Exception/Interrupt
Handlers</b></a><br />
<pre class="indent">
  0xFFFFFE00-0xFFFFFE0F   Program code of Game Pad interrupt handler
  0xFFFFFE10-0xFFFFFE1F   Program code of Timer Zero interrupt handler
  0xFFFFFE20-0xFFFFFE2F   Program code of Cartridge interrupt handler
  0xFFFFFE30-0xFFFFFE3F   Program code of Link interrupt handler
  0xFFFFFE40-0xFFFFFE4F   Program code of VIP interrupt handler
  0xFFFFFE50-0xFFFFFF5F   (Not used)
  0xFFFFFF60-0xFFFFFF7F   Program code of floating-point exception handler
  0xFFFFFF80-0xFFFFFF8F   Program code of zero division exception handler
  0xFFFFFF90-0xFFFFFF9F   Program code of invalid opcode exception handler
  0xFFFFFFA0-0xFFFFFFAF   Program code of handler for lower 16 TRAP vectors
  0xFFFFFFB0-0xFFFFFFBF   Program code of handler for upper 16 TRAP vectors
  0xFFFFFFC0-0xFFFFFFCF   Program code of address trap handler
  0xFFFFFFD0-0xFFFFFFEF   Program code of duplexed exception/MNI handler
  0xFFFFFFF0-0xFFFFFFFF   Program code of reset interrupt handler
</pre>

For more information on the exception and interrupt handlers, refer to the
<a href="#cpuexceptionsandinterrupts">CPU Exceptions &amp; Interrupts</a>
section.<br /><br />

As the CPU's <a href="#cpupcprogramcounter">program counter</a> is initialized
to 0xFFFFFFF0 on <a href="#systemreset">system reset</a>, the entry point in
a Virtual Boy ROM file is effectively the sixteenth-to-last byte in the
file.<br /><br />



<h1><a name="cpumemorymap">CPU Memory Map</a></h1>

The CPU memory bus of the Virtual Boy is 27 bits wide and is divided into 8,
16 MB segments. The upper 5 bits are masked out and produce mirrors of the
entire memory map according to the lower 27 bits.<br /><br />

<b>CPU Memory Map</b><br />
<pre class="indent">
0x00000000-0x00FFFFFF   VIP Memory and Control Registers
0x01000000-0x01FFFFFF   VSU Control Registers
0x02000000-0x02FFFFFF   Hardware Control Registers
0x03000000-0x03FFFFFF   Not Used
0x04000000-0x04FFFFFF   Cartridge Expansion
0x05000000-0x05FFFFFF   System WRAM
0x06000000-0x06FFFFFF   Cartridge RAM
0x07000000-0x07FFFFFF   Cartridge ROM
0x08000000-0xFFFFFFFF   Mirroring of CPU Memory Map
</pre>

<b>Cartridge Expansion</b><br /><br />

No commercial cartridges use this area. For all intents and purposes, it is a
general-purpose address range that passes through the cartridge.<br /><br />

An <a href="#cpuexceptionsandinterrupts">interrupt</a> exists that can be
raised by the expansion area. Cartridge interrupts have an exception code of
0xFE20 and branch CPU execution to address 0xFFFFFE20.<br /><br />

<b>System WRAM</b><br /><br />

The Virtual Boy has 64 KB of system RAM mapped to 0x05000000-0x0500FFFF. This
is the scratch memory for programs running on the CPU. The upper 8 bits are
masked out to produce mirrors of the entire RAM space according to the lower 16
bits.<br /><br />

<b>Cartridge RAM and Cartridge ROM</b><br /><br />

Cartridges can contain RAM chips of their own, and always contain ROM chips.
Cartridge RAM and ROM sizes must be some exponent of 2 bytes in size (but need
not be the same size), up to 16 MB each. Any bits above the range of the chips
are masked out and produce mirrors of the entire address space according to the
lower bits.<br /><br />



<h1><a name="virtualimageprocessorvip">Virtual Image Processor (VIP)</a></h1>

<b>Overview</b><br />
<a href="#vipoverview">VIP Overview</a><br />
<a href="#vipmemorymap">VIP Memory Map</a><br />
<a href="#vipdisplayprocedure">VIP Display Procedure</a><br />
<br />

<b>Memory</b><br />
<a href="#vipframebuffers">VIP Frame Buffers</a><br />
<a href="#vipcharacters">VIP Characters</a><br />
<a href="#vipbackgroundsegments">VIP Background Segments</a><br />
<a href="#vipobjects">VIP Objects</a><br />
<a href="#vipwindows">VIP Windows</a><br />
<a href="#vipcolumntable">VIP Column Table</a><br />
<br />

<b>Registers</b><br />
<a href="#vipinterrupts">VIP Interrupts</a><br />
<a href="#vipdisplayregisters">VIP Display Registers</a><br />
<a href="#vipbrightnessandpalettes">VIP Brightness and Palettes</a><br />
<a href="#vipdrawingregisters">VIP Drawing Registers</a><br />
<a href="#vipmiscregisters">VIP Miscellaneous Registers</a><br />
<br />

<h1><a name="vipoverview">VIP Overview</a></h1>

The Virtual Boy contains two LED screens manufactured by Reflection
Technologies, Inc. The screens each consist of a single column of LEDs and a
mirror that oscillates at 50.0 hz. The LEDs activate and deactivate with such
timing that by the time the light reflects off of the mirror and towards the
user's eye, it gives the illusion of a 2D matrix of pixels with varying
brightness. Each screen's mirror vibrates opposite the other to maintain
balance and optimize power consumption.<br /><br />

Virtual Boy's displays are 384x224 pixels in size, and the frame rate is 50.0
hz. <i>Editor's Note: Old documentation stated that the Virtual Boy has a
display period of 50.2 hz, but this is incorrect. The servo controller that
drives the displays monitors the mirrors, adjusting if necessary to maintain a
constant display period of 50.0 hz at all times.</i><br /><br />

<a name="vipimagecomposition"><b>Image Composition</b></a><br /><br />

Images on Virtual Boy can be composed from objects in video memory and/or by
directly manipulating the frame buffers. In the case of the former, the VIP
will read attributes and pixel data to produce images very quickly. Images are
rendered into frame buffer memory before being displayed. Each display has two
frame buffers, making both displays double buffered.<br /><br />

Graphical elements are arranged into <a href="#vipwindows">Windows</a>, known
in some circles as "worlds", which themselves are arranged on the screen and
can overlap with one another. The contents of Windows consist of the other
types of graphical elements and various effects like clipping regions
(analagous to "scrolling" on other systems) and affine transformations are
available.<br /><br />

<a name="vipimageelements"><b>Image Elements</b></a><br /><br />

The atomic unit of the Virtual Boy's graphics is the
<a href="#vipcharacters">Character</a>, also known as a tile. Characters
represent 8x8 patterns of pixel data and are used by the other types of
graphical elements. Characters cannot be used on the screen on their own, but
must be contained within a Window.<br /><br />

Individual Characters can be used directly via an
<a href="#vipobjects">Object</a>, also called a sprite. Objects consist of one
entire Character and can be placed at any arbitrary location in, partially in,
or entirely out of the bounds of their parent Windows. Objects also support
horizontal and vertical flipping of pixel data.<br /><br />

Characters can be arranged into 64x64 cell canvases or grids called
<a href="#vipbackgroundsegments">Background Segments</a>, for a total of
512x512 pixels each. Multiple Background Segments can be arranged within
Windows--forming a construct not unlike the canvas of Characters that the
Segment represents--which can then be shifted around inside the window to
produce a scrolling effect. This assembled construct is referred to as the
Background of the Window.<br /><br />

<a name="vipdirectrendering"><b>Direct Rendering</b></a><br /><br />

In addition to the windowing functionality of the graphical subsystem, the
program can directly access the <a href="#vipframebuffers">frame buffers</a>
for each screen and write pixel data into them in whatever way is desired. The
trade-off is that CPU time must be used to process images (whereas the VIP
operates independently from the CPU) and images are drawn more slowly than by
the VIP. In either case, it is still the responsibility of the VIP to transfer
completed images to the LED displays.<br /><br />



<h1><a name="vipmemorymap">VIP Memory Map</a></h1>

The VIP memory map is 19 bits wide. The upper 5 bits are masked out and produce
mirrors of the entire memory map according to the lower 19 bits.<br /><br />

<b>VIP Memory Map</b><br />
<pre class="indent">
0x00000000-0x00005FFF   Left Frame Buffer 0
0x00006000-0x00007FFF   CHR RAM Pattern Table 0
0x00008000-0x0000DFFF   Left Frame Buffer 1
0x0000E000-0x0000FFFF   CHR RAM Pattern Table 1
0x00010000-0x00015FFF   Right Frame Buffer 0
0x00016000-0x00017FFF   CHR RAM Pattern Table 2
0x00018000-0x0001DFFF   Right Frame Buffer 1
0x0001E000-0x0001FFFF   CHR RAM Pattern Table 3
0x00020000-0x0003D7FF   Background Segments and Window Parameter Table
0x0003D800-0x0003DBFF   Window Attributes
0x0003DC00-0x0003DFFF   Column Table
0x0003E000-0x0003FFFF   Object Attribute Memory (OAM)
0x00040000-0x0005DFFF   Mirroring of VIP Control Registers
<b>0x0005E000-0x0005FFFF</b>   <b>VIP Control Registers</b> (See below)
0x00060000-0x00077FFF   Not Used
0x00078000-0x00079FFF   Mirroring of CHR RAM Pattern Table 0
0x0007A000-0x0007BFFF   Mirroring of CHR RAM Pattern Table 1
0x0007C000-0x0007DFFF   Mirroring of CHR RAM Pattern Table 2
0x0007E000-0x0007FFFF   Mirroring of CHR RAM Pattern Table 3
0x00080000-0x00FFFFFF   Mirroring of VIP Memory Map
</pre>

<a name="vipcontrolregisters"><b>VIP Control Registers</a></b><br />
<pre class="indent">
0x0005F800 - Interrupt Pending
0x0005F802 - Interrupt Enable
0x0005F804 - Interrupt Clear
0x0005F820 - Display Status
0x0005F822 - Display Control
0x0005F824 - LED Brightness 1
0x0005F826 - LED Brightness 2
0x0005F828 - LED Brightness 3
0x0005F82A - LED Brightness Idle
0x0005F82E - Frame Repeat
0x0005F830 - Column Table Address
0x0005F840 - Drawing Status
0x0005F842 - Drawing Control
0x0005F844 - Version
0x0005F848 - OBJ Group 0 Pointer
0x0005F84A - OBJ Group 1 Pointer
0x0005F84C - OBJ Group 2 Pointer
0x0005F84E - OBJ Group 3 Pointer
0x0005F860 - BG Palette 0
0x0005F862 - BG Palette 1
0x0005F864 - BG Palette 2
0x0005F866 - BG Palette 3
0x0005F868 - OBJ Palette 0
0x0005F86A - OBJ Palette 1
0x0005F86C - OBJ Palette 2
0x0005F86E - OBJ Palette 3
0x0005F870 - Clear Color
</pre>

The VIP Control Registers must be accessed as halfwords (16 bits). Byte access
does not work, and any addresses except those listed above cannot be accessed.
<i>Editor's Note: Not that it would be recommended, but will word access
work?</i><br /><br />



<h1><a name="vipdisplayprocedure">VIP Display Procedure</a></h1>

The VIP display procedure occurs at 50.0hz, or at a 20 millisecond interval.
Activities occur during the procedure in the following order:<br /><br />

<div class="indent">
&bull; The <i>Start of Frame Processing</i> status is set.<br />
&bull; Depending on the value of the <a href="#vipmiscregisters">Frame
Repeat</a> register, the drawing procedure (see below) may occur. However, if
the previous frame's drawing procedure is still working, the <i>Drawing Exceeds
Frame Period</i> status will be set instead.<br />
&bull; At this point, depending on how much time is left, the CPU can further
manipulate the frame buffers prior to display.<br />
&bull; The left <a href="#vipframebuffers">frame buffer</a> is displayed. When
this completes, it will set the <i>Left Display Finished</i> status.<br />
&bull; The right frame buffer is displayed. When this completes, it will set
the <i>Right Display Finished</i> status.<br />
</div><br />

<a name="vipdrawingprocedure"><b>Drawing Procedure</b></a><br /><br />

According to the number of display frames specified by the
<a href="#vipmiscregisters">Frame Repeat</a> register, the drawing procedure
will be performed. Activities occur during the procedure in the following
order:<br /><br />

<div class="indent">
&bull; The <i>Start of Drawing</i> status is set.<br />
&bull; The first <a href="#vipframebuffers">frame buffer</a> used for each
display is buffer 0. The next drawing frame uses buffer 1, and it alternates in
this manner every other drawing frame.<br />
&bull; Frame buffers are processed 8 pixels at a time, starting at the top-left
corner of the image and working down. When rendering reaches the bottom of the
image, it continues from the top of the next column to the right. The
<i>Drawing Y Position Match</i> status can be configured for this time.<br />
<div class="indent">
&bull; Before any Window data is drawn, the pixels are populated with the
<a href="#vipbrightnessandpalettes">clear color</a>.<br />
&bull; All 32 Windows are processed, starting with Window 31 and working back
to Window 0. Windows with lesser indexes are drawn in front of Windows with
greater indexes.<br />
&bull; Windows of mode <a href="#vipwindowmodenormal">Normal</a>,
<a href="#vipwindowmodelineshift">Line Shift</a> and
<a href="#vipwindowmodeaffine">Affine</a> are drawn according to their
<a href="#vipwindowattributes">attributes</a> and optional parameters.
Windows of mode <a href="#vipwindowmodeobject">Object</a> are drawn using the
process described in the <a href="#vipwindowmodeobject">VIP Window Mode:
Object</a> section.<br />
&bull;  The Window <i>Stop</i> attribute can be used to cause the VIP to stop
drawing Windows immediately.<br />
</div>
&bull; The <i>Drawing Finished</i> status will be set.<br />
</div><br />

Various <a href="#vipinterrupts">VIP interrupts</a> can be configured when
various display statuses become set.<br /><br />

<i>Editor's Note: What is the exact timing of each stage of the display
procedure? Is it 10ms between Start of Frame Processing and the time the left
frame buffer is transmitted, and each display is 5ms? How many pixels of each
Window type can the VIP draw before Drawing Exceeds Frame
Period?</i><br /><br />



<h1><a name="vipframebuffers">VIP Frame Buffers</a></h1>

When the VIP sends images to the LED displays, it loads them from the active
frame buffer for each display. Both displays have two frame buffers. The VIP
will use one frame buffer for one display frame, then the other frame buffer
for the next display frame. The active frame buffer will alternate in this
manner every other frame, starting with frame buffer 0.<br />

<pre class="indent">
0x00000000-0x00005FFF   Left Frame Buffer 0
0x00008000-0x0000DFFF   Left Frame Buffer 1
0x00010000-0x00015FFF   Right Frame Buffer 0
0x00018000-0x0001DFFF   Right Frame Buffer 1
</pre>

The format of all four frame buffers is the same: there are 0x6000 bytes
representing a 384x256 pixel image at 2 bits per pixel. Pixels are stored in
column-major order (top to bottom first, then left to right) starting with the
least significant bits of the first byte. Only the first 224 pixels within each
column will be output to the display.<br /><br />

The VIP will compose images from graphical elements and store the results in
the frame buffers. The program may then further manipulate the frame buffers.
Afterward, the VIP will read from the frame buffers to send image data to the
LED displays. For more information, refer to the
<a href="#vipdrawingprocedure">VIP Drawing Procedure</a> section.<br /><br />



<h1><a name="vipcharacters">VIP Characters</a></h1>

The VIP contains enough Character memory for 2048 Characters. They are all
indexed sequentially from 0 to 2047, but their memory regions are not
contiguous. The reason for this likely comes from a design consideration where
Character memory fills in the otherwise unused regions in between
<a href="#vipframebuffers">frame buffer</a> memory.<br />

<pre class="indent">
0x00006000-0x00007FFF   CHR RAM Pattern Table 0
0x0000E000-0x0000FFFF   CHR RAM Pattern Table 1
0x00016000-0x00017FFF   CHR RAM Pattern Table 2
0x0001E000-0x0001FFFF   CHR RAM Pattern Table 3
</pre>

In addition to these four memory ranges, Character memory is mirrored linearly
from 0x00078000 to 0x0007FFFF, which is a contiguous region. The region of
addresses from 0x00060000 to 0x0007FFFF is otherwise unused, save for the
virtual mapping of Character memory addresses.<br />

<pre class="indent">
0x00078000-0x00079FFF   Mirroring of CHR RAM Pattern Table 0
0x0007A000-0x0007BFFF   Mirroring of CHR RAM Pattern Table 1
0x0007C000-0x0007DFFF   Mirroring of CHR RAM Pattern Table 2
0x0007E000-0x0007FFFF   Mirroring of CHR RAM Pattern Table 3
</pre>

The format of Characters is 16 bytes, representing an 8x8 pixel square with 2
bits per pixel. The lowest bits of the first byte represent the top-left pixel,
the highest bits of the second byte represent the top-right pixel, and so on
for all pixels within the Character.<br /><br />



<h1><a name="vipbackgroundsegments">VIP Background Segments</a></h1>

A Background Segment represents a 64x64 grid of 
<a href="#vipcharacters">Characters</a>, with optional effects such as flip and
<a href="#vipbrightnessandpalettes">Palette</a> selection.<br />

<pre class="indent">
0x00020000-0x0003D7FF   Background Segments and Window Parameter Table
</pre>

Background Segments occupy 8 KB of memory (0x2000 bytes), and there is enough
room in the memory region for 14 Segments (0x00020000-0x0003BFFF). There is an
additional 0x1800 bytes at the end of the region that cannot be used as Segment
memory, but can be used as <a href="#vipwindowattributes">Window</a> parameter
memory.<br /><br />

The boundary between Background Segments and Window parameters varies depending
on context; both types of data share the same memory. <i>Editor's Note: Is it
possible to interleave Window parameters in between Segments? Is it possible
to store parameter data in memory that belongs to a Segment already in
use?</i><br /><br />

Background Segments are 64x64 grids of cells, where the first entry specifies
the upper-left cell, the 64<sup>th</sup> entry specifies the upper-right cell,
and so on for all 4096 entries. Entries are 16 bits in size and have the
following format:<br />

<pre>
    15 14 13 12 11 10         0
   +-----+--+--+--+------------+
   | Pal |HF|VF|0 | Character  |
   +-----+--+--+--+------------+
Bits: 2   1  1  1       11
</pre>
<div class="indent">
<i>Character</i> - The index of the Character in CHR memory (0 to 2047) to
display in this cell.<br />
<i>VF - Vertical Flip</i> - If set, the Character will be flipped
vertically.<br />
<i>HF - Horizontal Flip</i> - If set, the Character will be flipped
horizontally.<br />
<i>Pal - Palette</i> - The <a href="#vipbrightnessandpalettes">Palette</a>
index (0 to 3) for this Character. Specified by the BG Palette registers.
</div><br />

The effect of using both the horizontal and vertical flip attributes is that
the Character will be rotated 180 degrees.<br /><br />



<h1><a name="vipobjects">VIP Objects</a></h1>

Objects, also known as sprites, are graphical elements that can be used to
display <a href="#vipcharacters">Characters</a> at arbitrary locations. This
contrasts with the <a href="#vipbackgroundsegments">Background</a>, which can
only display Characters at a fixed, 8-pixel interval. The trade-off is that
Objects require more memory per Character, and take longer to draw.<br />

<pre class="indent">
0x0003E000-0x0003FFFF   Object Attribute Memory (OAM)
</pre>

Object entries consist of 8 bytes each, and there is enough room in OAM for
1024 Object definitions. Not all Objects need to be used. Object definitions
are organized as 4 halfwords and have the following format:<br />

<div class="indent">
<pre>
   15 14                    0
  +--------------------------+
0 |            X             |
  +--+--+--------------------+
1 |L |R |      Parallax      |
  +--+--+--------------------+
2 |            Y             |
  +-----+--+--+--+-----------+
3 | Pal |HF|VF|0 | Character |
  +-----+--+--+--+-----------+
   15 14 13 12 11 10        0
</pre>
<i>X</i> - Signed X coordinate, in pixels, of the top-left pixel of the Object
within the parent <a href="#vipwindows">Window</a>. 0 is on the left.<br />
<i>Parallax</i> - The signed, X horizontal bias for parallax effects. Subtract
from <i>X</i> for the left display, and add to <i>X</i> for the right
display.<br />
<i>L - Left</i> - When set, Object will be drawn on the left display.<br />
<i>R - Right</i> - When set, Object will be drawn on the right display.<br />
<i>Y</i> - Signed Y coordinate, in pixels, of the top-left pixel of the Object
within the parent Window. 0 is on the top.<br />
<i>Character</i> - The index of the Character in CHR memory (0 to 2047) to
display in this Object.<br />
<i>VF - Vertical Flip</i> - If set, the Character will be flipped
vertically.<br />
<i>HF - Horizontal Flip</i> - If set, the Character will be flipped
horizontally.<br />
<i>Pal - Palette</i> - The <a href="#vipbrightnessandpalettes">Palette</a>
index (0 to 3) for this Object. Specified by the OBJ Palette registers.
</div><br />

The <i>Left</i> and <i>Right</i> fields operate independently from the
corresponding fields in the Window definition. A Window can be drawn to both
displays, yet Objects within it might not be.<br /><br />

The fourth halfword of the Object definition has the same format as the
halfword of the Background entry definition.<br /><br />

The effect of using both the horizontal and vertical flip attributes is that
the Character will be rotated 180 degrees.<br /><br />



<h1><a name="vipwindows">VIP Windows</a></h1>

<a href="#vipwindowattributes">VIP Window Attributes</a><br />
<a href="#vipwindowbackgrounds">VIP Window Backgrounds</a><br />
<a href="#vipwindowmodenormal">VIP Window Mode: Normal</a><br />
<a href="#vipwindowmodelineshift">VIP Window Mode: Line Shift</a><br />
<a href="#vipwindowmodeaffine">VIP Window Mode: Affine</a><br />
<a href="#vipwindowmodeobject">VIP Window Mode: Object</a><br />
<br />



<h1><a name="vipwindowattributes">VIP Window Attributes</a></h1>

Windows are the root construct from which all graphics are drawn by the VIP.
They can specify either <a href="#vipbackgroundsegments">Backgrounds</a> or
groups of <a href="#vipobjects">Objects</a>, both of which specify pixel data
from <a href="#vipcharacters">Characters</a>. Their position, size and contents
can be configured.<br />

<pre class="indent">
0x0003D800-0x0003DBFF   Window Attributes
</pre>

Window entries consist of 32 bytes each, and there is enough room in memory for
32 Windows. Not all Windows need to be used.<br /><br />

<span class="br"></span>

Window definitions are organized as 16 halfwords and have the following
format:<br />

<div class="indent">
<pre>
    15 14 13 12 11 10 9 8  7   6   5 4 3     0
   +--+--+-----+-----+---+---+----+---+-------+
 0 |L |R |Mode | BGW |BGH|OoB|Stop|0 0|BaseSeg|
   +--+--+-----+-----+---+---+----+---+-------+
 1 |                    X                     |
   +------------------------------------------+
 2 |                 Parallax                 |
   +------------------------------------------+
 3 |                    Y                     |
   +------------------------------------------+
 4 |                   BG X                   |
   +------------------------------------------+
 5 |               BG Parallax                |
   +------------------------------------------+
 6 |                   BG Y                   |
   +------------------------------------------+
 7 |                  Width                   |
   +------------------------------------------+
 8 |                  Height                  |
   +------------------------------------------+
 9 |            Parameter Address             |
   +------------------------------------------+
10 |          Out of Bounds Character         |
   +------------------------------------------+
11 |                                          |
12 |                                          |
13 |             VIP Scratch Area             |
14 |                                          |
15 |                                          |
   +------------------------------------------+
</pre>
<i>BaseSeg - Base Background Segment</i> - The index of the first Background
Segment (0 to 13) of the Window's background.<br />
<i>Stop - Stop Drawing Windows</i> - If set, then this Window and all Windows
with lesser indexes will not be drawn.<br />
<i>OoB - Out of Bounds</i> - Determines what is drawn when the Window's
Background is scrolled beyond the bounds of the Background itself:<br />
<div class="indent">
&bull; 0 = The entire background will repeat as if tessellated.<br />
&bull; 1 = The <i>Out of Bounds Character</i> will be drawn in all cells beyond
the bounds of the Background.<br />
</div>
<i>BGH - BG Height</i> - Raising 2 to the power of this field will yield the
height of the Window's background, in Background Segments.<br />
<i>BGW - BG Width</i> - Raising 2 to the power of this field will yield the
width of the Window's background, in Background Segments.<br />
<i>Mode</i> - Indicates how the Window will draw its contents:<br />
<div class="indent">
&bull; 0 = <a href="#vipwindowmodenormal">Normal</a><br />
&bull; 1 = <a href="#vipwindowmodelineshift">Line Shift</a><br />
&bull; 2 = <a href="#vipwindowmodeaffine">Affine</a><br />
&bull; 3 = <a href="#vipwindowmodeobject">Object</a><br />
</div>
<i>L - Left</i> - When set, Window will be drawn on the left display.<br />
<i>R - Right</i> - When set, Window will be drawn on the right display.<br />
<i>X</i> - Signed X coordinate, in pixels, of the top-left pixel of the Window
within the display. 0 is on the left.<br />
<i>Parallax</i> - The signed, X horizontal bias for parallax effects. Subtract
from <i>X</i> for the left display, and add to <i>X</i> for the right
display.<br />
<i>Y</i> - Signed Y coordinate, in pixels, of the top-left pixel of the Window
within the display. 0 is on the top.<br />
<i>BG X</i> - Signed X coordinate of the pixel within the Background to be
displayed as the top-left pixel of the Window. 0 is the left edge of the
Background.<br />
<i>BG Parallax</i> - The signed, X horizontal bias for Background parallax
effects. Subtract from <i>BG X</i> for the left display, and add to <i>BG X</i>
for the right display.<br />
<i>BG Y</i> - Signed Y coordinate of the pixel within the Background to be
displayed as the top-left pixel of the Window. 0 is the top edge of the
Background.<br />
<i>Width</i> - The unsigned width of the Window, in pixels. Add 1 to this
value for the actual width.<br />
<i>Height</i> - The unsigned height of the Window, in pixels. Add 1 to this
value for the actual height.<br />
<i>Parameter Address</i> - Offset into BG Segment/Window Params memory where
any parameters for this Window are stored. To resolve the actual address,
multiply this value by 2, then add 0x00020000.<br />
<i>Out of Bounds Character</i> - If specified, references the Background cell
entry index relative to <i>Base Background Segment</i>. This Character will be
drawn when the Window's Background is scrolled beyond the bounds of the
Background itself.<br />
<i>VIP Scratch Area</i> - The VIP uses this memory as working variables during
the drawing process. The CPU is not allowed to write to this area. <i>Editor's
Note: Can the CPU read from this area?</i>
</div><br />

<span class="br"></span>

<i>Base Background Segment</i> must be in the range of 0 to 13.<br /><br />

Window widths must be in the range of 1 to 384 pixels. Window heights must be
in the range of 8 to 224 pixels for all Window modes except Affine, and 1 to
224 for Affine mode Windows.<br /><br />

The lowest 4 bits of <i>Parameter Address</i> must be 0. That is to say, the
parameter address must be divisible by 16.<br /><br />

<i>Editor's Note: Can the OoB Char be taken from a Segment that isn't part of
the Window's Background?</i><br /><br />

For information regarding how the VIP processes window data, refer to the
<a href="#vipdrawingprocedure">VIP Drawing Procedure</a> section.<br /><br />



<h1><a name="vipwindowbackgrounds">VIP Window Backgrounds</a></h1>

For all <a href="#vipwindowattributes">Window modes</a> except
<a href="#vipwindowmodeobject">Object</a>, the Window's Background is
constructed with <a href="#vipbackgroundsegments">Background Segments</a>. The
Segments used are always sequential, starting with the Segment specified by the
Window's <i>Base Background Segment</i>
<a href="#vipwindowattributes">attribute</a>.<br /><br />

Backgrounds must consist of 1, 2, 4 or 8 Segments, and any combination of <i>BG
Width</i> and <i>BG Height</i> that satisfies that requirement is vaild. The
value of the Window's <i>Base Background Segment</i> field must be divisible by
the number of Segments in the Background, and there must be enough Segment
memory from that point to accommodate every Segment in the Background. For
example, a 4-Segment Background may begin with Segments 0, 4 or 8. It cannot
begin with Segment 12, however, because there is only memory for 14 Segments
and 12 + 4 > 14.<br /><br />

The top-left Segment is the first Segment, and is the one specified by the
Window's <i>Base Background Segment</i> attribute. Segment indexes then
increment by 1 in row-major order. For example, a Background that is 4 Segments
wide, 2 Segments tall, and a <i>Base Background Segment</i> of 0: the top-left
Segment is 0; the top-right Segment is 3; the bottom-left Segment is 4; and the
bottom-right Segment is 7.<br /><br />



<h1><a name="vipwindowmodenormal">VIP Window Mode: Normal</a></h1>

For Normal mode Windows, no additional information is necessary: all of the
applicable fields are specified in
<a href="#vipwindowattributes">VIP Window Attributes</a>.<br /><br />

<div class="indent">
&bull; The Windows' Backgrounds are selected as specified.<br />
&bull; Windows are drawn on the specified displays.<br />
&bull; Windows are drawn with the given widths, heights and Y
coordinates.<br />
&bull; The Windows' X positions are calculated as <i>X - Parallax</i> for the
left display and <i>X + Parallax</i> for the right display.<br />
&bull; The left edge of the visible clipping regions within the Windows'
Backgrounds are calculated as <i>BG X - BG Parallax</i> for the left display
and <i>BG X + BG Parallax</i> for the right display.<br />
&bull; The top edge of the visible clipping regions within the Windows'
Backgrounds are given by <i>BG Y</i>.<br />
&bull; The width and height of the visible clipping regions within the Windows'
Backgrounds are the same as the Windows' width and height.<br />
&bull; If pixels past the bounds of the Background are visible in the Window,
it will either repeat the Background or the Out of Bounds Character (according
to configuration).
</div><br />

The <i>Parameter Address</i> field is not used for Windows with mode
Normal.<br /><br />


<h1><a name="vipwindowmodelineshift">VIP Window Mode: Line Shift</a></h1>

Windows of mode Line Shift consist of all of the functionality of mode
<a href="#vipwindowmodenormal">Normal</a>, with additional processing of the
source X coordinate within the Window's Background. Each row of pixels within
the Window can specify horizontal shifts for each display independently,
further modifying the <i>BG X</i> attribute.<br /><br />

The <i>Parameter Address</i> field specifies the address within the
<a href="#vipbackgroundsegments">BG Segment</a>/Window Parameter memory to use
for Line Shift parameters:<br />

<pre class="indent">
0x00020000-0x0003D7FF   Background Segments and Window Parameter Table
</pre>

The memory used for Line Shift parameters must contain enough entries to
account for every row of pixels in the Window. That is to say, the number of
Line Shift entries should be at least the height of the Window. Line Shift
entries are 4 bytes, organized into two halfwords and with the following
format:<br />

<div class="indent">
<pre>
 15             0
+----------------+
|   Left Shift   |
+----------------+
|  Right Shift   |
+----------------+
</pre>
<i>Left Shift</i> - The signed shift amount for the corresponding line in the
left display. This is added to the source X coordinate within the Background.
The final Background source X coordinate is calculated as <i>BG X - BG Parallax
+ Left Shift</i><br />
<i>Right Shift</i> - The signed shift amount for the corresponding line in the
right display. This is added to the source X coordinate within the Background.
The final Background source X coordinate is calculated as <i>BG X + BG Parallax
+ Right Shift</i><br />
</div><br />

The first Line Shift entry applies to the top row of pixels in the Window, and
each additional entry proceeds towards the bottom.<br /><br />

Line Shift values must be in the range of -511 to 511.<br /><br />



<h1><a name="vipwindowmodeaffine">VIP Window Mode: Affine</a></h1>

The Affine Window mode on Virtual Boy features similar functionality to the
famous "Mode 7" screen mode of the Super NES. With it, various effects can be
applied to Window Backgrounds, including scaling, rotation and perspective
projection. In contrast to the SNES, the Virtual Boy can provide these
transformations to any number of Windows individually.<br /><br />

Windows of mode Affine consist of all of the functionality of mode
<a href="#vipwindowmodenormal">Normal</a>, with the exception that the source X
and Y coordinates within the Window's Background are calculated differently.
The <i>BG X</i>, <i>BG Parallax</i> and <i>BG Y</i> attributes are not used in
Affine mode.<br /><br />

The <i>Parameter Address</i> <a href="#vipwindowattributes">attribute</a>
specifies the address within the <a href="#vipbackgroundsegments">BG
Segment</a>/Window Parameter memory to use for Affine parameters:<br />

<pre class="indent">
0x00020000-0x0003D7FF   Background Segments and Window Parameter Table
</pre>

The memory used for Affine parameters must contain enough entries to account
for every row of pixels in the Window. That is to say, the number of Affine
entries should be at least the height of the Window. Affine entries are 16
bytes, organized into eight halfwords and with the following format:<br />

<div class="indent">
<pre>
   15             0
  +----------------+
0 |      BG X      |
  +----------------+
1 |  BG Parallax   |
  +----------------+
2 |      BG Y      |
  +----------------+
3 | BG X Increment |
  +----------------+
4 | BG Y Increment |
  +----------------+
5 |                |
6 |  VIP Scratch   |
7 |                |
  +----------------+
</pre>
<i>BG X</i> - Signed X coordinate of the pixel within the Background to be
displayed as the top-left pixel of the Window. 0 is the left edge of the
Background. This value is stored as 13.3 fixed point.<br />
<i>BG Parallax</i> - The signed, X horizontal bias for Background parallax
effects. This is a 16-bit integer. See below for how this value is used.<br />
<i>BG Y</i> - Signed Y coordinate of the pixel within the Background to be
displayed as the top-left pixel of the Window. 0 is the top edge of the
Background. This value is stored as 13.3 fixed point.<br />
<i>BG X Increment</i> - For every pixel along the corresponding row of output
pixels in the Window, add this value to the Background source X coordinate,
starting at <i>BG X</i>. This value is stored as 7.9 fixed point.<br />
<i>BG Y Increment</i> - For every pixel along the corresponding row of output
pixels in the Window, add this value to the Background source Y coordinate,
starting at <i>BG Y</i>. This value is stored as 7.9 fixed point.<br />
<i>VIP Scratch</i> - The VIP uses this memory as working variables during the
drawing process. The CPU is not allowed to write to this area. <i>Editor's
Note: Can the CPU read from this area?</i><br />
</div><br />

The <i>BG X</i> and <i>BG Y</i> parameters are stored as fixed-point fields,
where the upper 13 bits represent the integer and the lower 3 bits represent
the fraction (halves, quarters and eighths).<br /><br />

The <i>BG X Increment</i> and <i>BG Y Increment</i> parameters are stored as
fixed-point fields, where the upper 7 bits represent the integer and the lower
9 bits represent the fraction (halves, quarters, eighths, etc.).<br /><br />

<span class="br"></span>

<a name="vipaffineparallax"><b>Affine Parallax</b></a><br /><br />

The parallax calculations for Affine Windows works differently than it does for
<a href="#vipwindowmodenormal">Normal</a>,
<a href="#vipwindowmodelineshift">Line Shift</a> and
<a href="#vipwindowmodeobject">Object</a>:<br /><br />

<div class="indent">
&bull; If <i>BG Parallax</i> is negative, it is added to the Window X
coordinate index prior to fetching the pixel from the Background for the left
display. The right display is not affected.<br />
&bull; If <i>BG Parallax</i> is non-negative, it is added to the Window X
coordinate index prior to fetching the pixel from the Background for the right
display. The left display is not affected.<br />
</div><br />

For any given pixel within a row of pixels in a Window, denoted by
<code>Window_X</code> and starting at 0, the output pixels for the left and
right displays can be determined with the following algorithm:<br />

<pre class="indent">
X1 = BG_X + BG_X_Increment *  Window_X
Y1 = BG_Y + BG_Y_Increment *  Window_X
X2 = BG_X + BG_X_Increment * (Window_X + BG_Parallax)
Y2 = BG_Y + BG_Y_Increment * (Window_X + BG_Parallax)

If BG_Parallax < 0 Then
    Output_Left  = Background.Pixel(X2, Y2)
    Output_Right = Background.Pixel(X1, Y1)
Else
    Output_Left  = Background.Pixel(X1, Y1)
    Output_Right = Background.Pixel(X2, Y2)
End If
</pre>

The values of the source X and Y coordinates to fetch from the Background must
be in the range of -4096 to 4096. <i>Editor's Note: What happens if they go out
of bounds?</i><br /><br />



<h1><a name="vipwindowmodeobject">VIP Window Mode: Object</a></h1>

Up to four Windows can be specified as type Object.
<a href="#vipobjects">Objects</a> are organized into four groups, by index, and
entire groups are drawn by specifying Object Windows.<br /><br />

No Background information is used in Object Windows. All
<a href="#vipwindowattributes">attributes</a> that do not pertain to Background
information still apply.<br /><br />

Like the Windows themselves, <a href="#vipdrawingprocedure">the VIP will
draw</a> Objects in reverse order, starting with the highest specified index
and counting down. Objects with lesser indexes will be drawin in front of
Objects with greater indexes. The exact indexes to start and stop at are
specified by the OBJ Group registers.<br /><br />

<b>0x0005F848 - OBJ Group 0 Pointer (R/W)<br />
0x0005F84A - OBJ Group 1 Pointer (R/W)<br />
0x0005F84C - OBJ Group 2 Pointer (R/W)<br />
0x0005F84E - OBJ Group 3 Pointer (R/W)</b><br />
<pre class="indent">
Bits 15-10   Not used
Bits  9-0    Object Index
</pre>

For each display frame, the VIP keeps track of which Object groups have been
drawn. The first time an Object Window is drawn, it will contain Object group
3. The second time, it will contain Object group 2. This continues for groups 1
and 0.<br /><br />

The first Object drawn from a group in an Object Window is specified by the
OBJ Group register that corresponds with that Object group. For example, OBJ
Group 2 Pointer corresponds with Object group 2, and the register itself
contains the index of the first Object to draw in group 2. Object indexes range
from 0 to 1023.<br /><br />

The VIP will continue to draw Objects, decreasing the index by 1 each time, for
as long as the current Object index is greater than the index specified by the
next OBJ Group register. For example, if OBJ Group 2 Pointer is set to 123 and
OBJ Group 1 Pointer is set to 45, then Object group 2 will consist of all
Objects with indexes in the range of 46 to 123.<br /><br />

If the next OBJ Group register has a value greater than or equal to the current
OBJ Group register, or if the current Object group being drawn is group 0, then
all remaining Objects through index 0 will be drawn. Having said that,
additional Object Windows can still be used, because the VIP starts drawing
Objects at the values specified in the OBJ Group registers each
time.<br /><br />

Object Windows used after Object group 0 has been drawn during one display
frame will not have any effect. <i>Editor's Note: Is this
correct?</i><br /><br />



<h1><a name="vipcolumntable">VIP Column Table</a></h1>

In order to produce a 2-dimensional matrix of pixels on a display consisting of
1 column of LEDs, the Virtual Boy uses two oscillating mirrors and times the
emission of light from the LEDs accordingly. This physically works due to the
afterimage properties of the human retina. However, this means that the amount
of time each column of pixels should be displayed varies as the angle of the
mirror relative to the LEDs changes. To correct for this movement, the column
table was implemented.<br />

<pre class="indent">
0x0003DC00-0x0003DFFF   Column Table
</pre>

The column table is divided into halves: 0x0003DC00 to 0x0003DDFF represent the
table vaules for the left display, and 0x0003DE00 to 0x0003DFFF represent the
table values for the right display. Table values are 16 bits in size, and there
is enough room for 512 entries total.<br /><br />

The format of a column table entry is as follows:<br />

<div class="indent">
<pre>
 15     8 7      0
+--------+--------+
| Repeat |  Time  |
+--------+--------+
</pre>
<i>Time</i> - The amount of time, in units of 200 nanoseconds, to display the
corresponding four columns. Add 1 to this value. Must be 0x2C &lt;= Time &lt;=
0xFE<br />
<i>Repeat</i> - The number of times to repeat the LED emission for each of the
corresponding four columns. Add 1 to this value.
</div><br />

The column table contains 96 significant timing values, each corresponding with
4 columns of display for a total of 384 columns. Additional column entries are
provided to stabilize the display when beyond the bounds of the display frame.
The amount of time a column remains active must be greater than the total time
spent emitting light on that column.<br /><br />

The number of times light is emitted on a column is a brightness multiplier for
that column. By using low values in the <a href="#vipbrightnessandpalettes">LED
Brightness registers</a>, the <i>Repeat</i> field in the column table can be
used for varying levels of brightness horizontally along the
display.<br /><br />

<i>Editor's Note: For all intents and purposes, the maximum brightness of a
column as specified by the Brightness registers, times the number of
repetitions, should not be greater than 127.</i><br /><br />

The column table entries at 0x0003DCA4 and 0x0003DEA4 represent the width of
the 4 right-most columns of the left and right displays, respectively.
Likewise, the entries at 0x0003DD62 and 0x0003DF62 represent the 4 left-most
columns of the left and right displays, respectively.<br /><br />

<span class="br"></span>

<a name="vipcolumntableaddress"><b>0x0005F830 - Column Table Address
(R)</b></a><br />
<pre class="indent">
Bit 15-8  Right Table Address
Bit  7-0  Left Table Address
</pre>
Set by the VIP while outputting to the displays. Counts down for each display,
96 times during each display frame. The values in this register, multiplied by
2, result in the addresses relative to 0x0003DC00 (left) and 0x0003DE00 (right)
to be read by the VIP.<br /><br />

Nintendo supplies a default column table for developers. In normal situations,
this will never need to be changed, with the possible exception of the
<i>Repeat</i> values:<br />

<pre class="indent" style="font-size: 10px;">
<i>0000   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0010   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0020   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0030   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0040   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0050   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0060   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0070   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 E0 00 BC 00
0080   A6 00 96 00 8A 00 82 00  7A 00 74 00 6E 00 6A 00
0090   66 00 62 00 60 00 5C 00  5A 00 58 00 56 00 54 00</i>
00A0   <i>52 00 50 00</i> 50 00 4E 00  4C 00 4C 00 4A 00 4A 00
00B0   48 00 48 00 46 00 46 00  46 00 44 00 44 00 44 00
00C0   42 00 42 00 42 00 40 00  40 00 40 00 40 00 40 00
00D0   3E 00 3E 00 3E 00 3E 00  3E 00 3E 00 3E 00 3C 00
00E0   3C 00 3C 00 3C 00 3C 00  3C 00 3C 00 3C 00 3C 00
00F0   3C 00 3C 00 3C 00 3C 00  3C 00 3C 00 3C 00 3C 00
0100   3C 00 3C 00 3C 00 3C 00  3C 00 3C 00 3C 00 3C 00
0110   3C 00 3C 00 3C 00 3C 00  3C 00 3C 00 3C 00 3C 00
0120   3C 00 3E 00 3E 00 3E 00  3E 00 3E 00 3E 00 3E 00
0130   40 00 40 00 40 00 40 00  40 00 42 00 42 00 42 00
0140   44 00 44 00 44 00 46 00  46 00 46 00 48 00 48 00
0150   4A 00 4A 00 4C 00 4C 00  4E 00 50 00 50 00 52 00
0160   54 00 56 00 <i>58 00 5A 00  5C 00 60 00 62 00 66 00
0170   6A 00 6E 00 74 00 7A 00  82 00 8A 00 96 00 A6 00
0180   BC 00 E0 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
0190   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
01A0   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
01B0   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
01C0   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
01D0   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
01E0   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00
01F0   FE 00 FE 00 FE 00 FE 00  FE 00 FE 00 FE 00 FE 00</i>
</pre>

These values should be written to both 0x0003DC00 and 0x0003DE00. The list can
be compacted: the high bytes are always 0x00, and the bottom half is radially
symetrical to the top. It can be stored as 128 bytes, where values are written
to the low addresses and counting up, as well as to the high addresses and
counting down.<br /><br />



<h1><a name="vipinterrupts">VIP Interrupts</a></h1>

The VIP has three registers for managing
<a href="#cpuexceptionsandinterrupts">interrupt</a>, and they all have the
same format:<br /><br />

<b>0x0005F800 - Interrupt Pending (R)<br />
0x0005F802 - Interrupt Enable (R/W)<br />
0x0005F804 - Interrupt Clear (W)</b><br />

<pre class="indent">
Bit  15     Drawing Exceeds Frame Period
Bit  14     Drawing Finished
Bit  13     Drawing Y Position Match
Bits 12-5   Not used
Bit   4     Start of Frame Processing
Bit   3     Start of Drawing
Bit   2     Right Display Finished
Bit   1     Left Display Finished
Bit   0     Display Not Ready
</pre>

Interrupt Pending bits are set when their corresponding situations occur. These
bits will still become set even if not selected by Interrupt
Enable</i><br /><br />

Interrupt Enable selects which situations can raise VIP interrupts.<br /><br />

Interrupt Clear resets and acknowledges bits. To clear all pending interrupts,
write to this register the same value read from Interrupt Pending.<br /><br />

When any enabled interrupt condition is met, a VIP interrupt is raised. VIP
interrupts have an exception code of 0xFE40 and branch CPU execution to address
0xFFFFFE40.<br /><br />

For information on exactly when VIP interrupts occur relative to one another,
refer to the <a href="#vipdisplayprocedure">VIP Display Procedure</a>
section.<br /><br />

The Display Exceeds Frame Period condition occurs when the VIP takes too much
time drawing Window graphics, causing the rendering to spill over into the time
when the left frame buffer is to be displayed.<br /><br />

The Drawing Finished condition occurs when all Window graphics have completed
rendering to the frame buffers. Depending on how much Window data was
processed, there may be enough time for the CPU to further manipulate the
frame buffers prior to being displayed. Otherwise, this condition is useful as
an analog to "VBlank", where it is safe to modify Window data without affecting
display output.<br /><br />

Drawing Y Position Match occurs when the <i>Y Position</i> fields of the
Drawing Status and Drawing Control registers match. This can happen once per
column of pixels.<br /><br />

Start of Frame Processing occurs when the entire display procedure begins for
each frame.<br /><br />

Start of Drawing occurs at the same time as Start of Frame Processing, but
may not occur according to the Frame Repeat register.<br /><br />

Right Display Finished and Left Display Finished occur when the right and left
displays (respectively) have completed LED emission and the corresponding frame
buffers are no longer in use.<br /><br />

Display Not Ready occurs when display components are out of sync. The internal
display controller will eventually correct itself.<br /><br />



<h1><a name="vipdisplayregisters">VIP Display Registers</a></h1>

<b>0x0005F820 - Display Status (R)</b><br />
<pre class="indent">
Bits 15-11   Not used
Bit  10      Column Table Address Locked
Bit   9      Display Sync Signals Enabled
Bit   8      VIP Memory is Refreshing
Bit   7      Display Procedure Beginning
Bit   6      Display is Ready
Bit   5      Right FB1 Being Displayed
Bit   4      Left FB1 Being Displayed
Bit   3      Right FB0 Being Displayed
Bit   2      Left FB0 Being Displayed
Bit   1      Display is Enabled
Bit   0      Not used
</pre>

Display Procedure is Beginning will be set to 1 at the beginning of the
<a href="#vipdisplayprocedure">Display Procedure</a>.<br /><br />

Bits 5-2 can be read as a single value to determine whether the display is
currently busy. If none of the frame buffers are being displayed, meaning the
4-bit value is zero, then it is safe to modify them.<br /><br />

<b>0x0005F822 - Display Control (W)</b><br />
<pre class="indent">
Bits 15-11   Not used
Bit  10      Lock Column Table Address
Bit   9      Enable Display Sync Signals
Bit   8      Refresh VIP Memory
Bit   7-2    Not used
Bit   1      Enable Display
Bit   0      Reset Display
</pre>

Lock Column Table Address prevents the VIP from reading new values from the
column table, instead re-using the previously read value.<br /><br />

Enable Display Sync Signals is required to transfer frame buffer data to the
LEDs. <i>Editor's Note: Will other VIP interrupts still occur, just without
any LED emissions?</i><br /><br />

Writing 1 to Refresh VIP Memory will initiate a memory-refresh cycle on VIP
memory. Writing 0 has no effect. It is only used to perform the refresh
operation.<br /><br />

Setting Enable Display to 1 enables the display, and setting it to 0 turns the
display off.<br /><br />

Writing 1 to Reset Display sends a reset signal to the VIP. The VIP will idle
until the start of the next display frame. It will also clear the following
interrupts in the <a href="#vipinterrupts">Interrupt Pending</a>
register:<br /><br />

<div class="indent">
&bull; Drawing Exceeds Frame Period<br />
&bull; Start of Frame Processing<br />
&bull; Start of Drawing<br />
&bull; Right Display Finished<br />
&bull; Left Display Finished<br />
&bull; Display Not Ready<br />
</div><br />

Writing 0 to Reset Display has no effect. It is only used to perform the reset
operation.<br /><br />



<h1><a name="vipbrightnessandpalettes">VIP Brightness and Palettes</a></h1>

<b>0x0005F824 - LED Brightness 1 (W)<br />
0x0005F826 - LED Brightness 2 (W)<br />
0x0005F828 - LED Brightness 3 (W)<br />
0x0005F82A - LED Brightness Idle (W)</b><br />
<pre class="indent">
Bits 15-8   Not used
Bits  7-0   Brightness
</pre>

The values specified in the Brightness registers indicate how long, in units of
50 nanoseconds, LEDs should emit light for the corresponding color values. The 
longer light is emitted for a single pixel, the brighter that pixel will
appear.<br /><br />

Brightness settings 1 and 2 are used directly. Brightness setting 3, however,
is actually the sum of the LED Brightness 1, 2 and 3 registers. For this
reason, if LED Brightness 1 is set to some number X, Brightness 2 to 2X, and
Brightness 3 to 0, the net brightness of Brightness 3 is actually X + 2X + 0 =
3X.<br /><br />

The emission period for a single pixel is equal to the time specified by the
corresponding Brightness register, plus the time specified by the Brightness
Idle register, plus five inactive clocks (250 nanoseconds). This emission
period is repeated for each pixel according to the configuration in the
<a href="#vipcolumntable">column table</a>. The number of repetitions is
effectively a brightness multiplier: 2 repetitions is twice as bright, 3
repetitions is three times as bright, etc.<br /><br />

The product of the emission period times the number of repetitions must be less
than the total display period for the column of pixels in question.<br /><br />

The LED Brightness Idle register does not represent the brightness timing for
any color value. It is, however, added to the end of all columns' emission
periods, but without emitting any light.<br /><br />

<i>Editor's Note: The calculations don't seem to match up with observations
during bench testing. Testing shows that the maximum effective brightness is
128, or slightly less than that. This might be due to the actual maximum
physical brightness of the LEDs, however.</i><br /><br />

<b>0x0005F860 - BG Palette 0 (R/W)<br />
0x0005F862 - BG Palette 1 (R/W)<br />
0x0005F864 - BG Palette 2 (R/W)<br />
0x0005F866 - BG Palette 3 (R/W)<br />
0x0005F868 - OBJ Palette 0 (R/W)<br />
0x0005F86A - OBJ Palette 1 (R/W)<br />
0x0005F86C - OBJ Palette 2 (R/W)<br />
0x0005F86E - OBJ Palette 3 (R/W)</b><br />
</pre>
<pre class="indent">
Bits 15-8   Not used
Bits  7-6   Color for Pixel Value 3
Bits  5-4   Color for Pixel Value 2
Bits  3-2   Color for Pixel Value 1
Bits  1-0   Not used
</pre>

When a pixel is fetched from a <a href="#vipcharacters">Character</a>, it is
passed through one of these Palettes. The exact Palette to use is specified in
the <a href="#vipbackgroundsegments">Background entry</a> or
<a href="#vipobjects">Object</a> referencing the Character. The values in the
Palette for each pixel value correspond with the brightness registers of the
same index.<br /><br />

For example, let's say a Character pixel is read, and its value is 2. Let's
also say that the Character was used in a Background, and the specified
Palette was 1. Lastly, let's say that the value in BG Palette 1 is 0x00B8.
Pixel value 2 corresponds with bits 5-4, which in 0x00B8 come out to 3.
Therefore, the Brightness 3 register is used as the color for this
pixel.<br /><br />

As there is no Brightness register for color 0, specifying a Palette value of
0 will be unconditionally black.<br /><br />

A transparent pixel will occur if the pixel value in the Character is
0.<br /><br />

<b>0x0005F870 - Clear Color (R/W)</b><br />
<pre class="indent">
Bits 15-2   Not used
Bits  1-0   Clear Color
</pre>

When the VIP begins rending using Window data, it first resets the entire
<a href="#vipframebuffers">frame buffer</a> to the value specified in this
register. Upon display, the Brightness register of the same index will be used
to generate the color.<br /><br />

As there is no Brightness register for color 0, specifying a clear color of 0
will be unconditionally black.<br /><br />



<h1><a name="vipdrawingregisters">VIP Drawing Registers</a></h1>

<b>0x0005F840 - Drawing Status (R)</b><br />
<pre class="indent">
Bit  15      Drawing at Y Position
Bits 14-13   Not used
Bits 12-8    Current Y Position
Bit   4      Drawing Exceeds Frame Period
Bit   3      Writing to Frame Buffer 0
Bit   2      Writing to Frame Buffer 1
Bit   1      Drawing is Enabled
Bit   0      Not used
</pre>

Drawing at Y Position will be set when Current Y Position matches the Y
Position field in the Drawing Control register.<br /><br />

The Display Exceeds Frame Period condition occurs when the VIP takes too much
time drawing Window graphics, causing the rendering to spill over into the time
when the left <a href="#vipframebuffers">frame buffer</a> is to be
displayed.<br /><br />

VIP interrupts can be rased for the above status conditions. For more
information, refer to <a href="#vipdisplayprocedure">Display
Procedure</a>.<br /><br />

Current Y Position indicates which pixels are being rendered by the VIP within
the current column of pixels. Pixels are processed in units of 8, so multiply
this value by 8 for the actual vertical coordinate within the frame
buffer.<br /><br />

Writing to Frame Buffer 0 and Writing to Frame Buffer 1 indicate which frame
buffer is being rendered to for this frame. They will not both be set in a
single read.<br /><br />

<b>0x0005F842 - Drawing Control (W)</b><br />
<pre class="indent">
Bits 15-13   Not used
Bits 12-8    Y Position
Bit   1      Enable Drawing
Bit   0      Reset Drawing
</pre>

Y Position is used in conjunction with the Current Y Position field of Drawing
Status, and the Drawing Y Position Match field of
<a href="#vipinterruptregisters">Interrupt Enable</a> to configure an
interrupt to occur at a particular Y position for each column of pixels being
rendered. Multiply this value by 8 for the actual Y position within the
iamge.<br /><br />

Setting Enable Drawing to 1 enables rendering of Window data to the frame
buffers, and setting it to 0 turns drawing off.<br /><br />

Writing 1 to Reset Drawing sends a drawing reset signal to the VIP. Drawing
will stop, but one of the Writing to Frame Buffer flags will become set in
Drawing Status. Do not access any <a href="#vipwindowmodeobject">Object
Group</a>, <a href="#vipbrightnessandpalettes">Palette</a>, or the
<a href="#vipmiscregisters">Version</a> register until both flags are
cleared.<br /><br />

Reset Drawing will also clear the following interrupts in the
<a href="#vipinterrupts">Interrupt Pending</a> register:<br /><br />

<div class="indent">
&bull; Drawing Exceeds Frame Period<br />
&bull; Drawing Finished<br />
&bull; Display Not Ready<br />
</div><br />

Writing 0 to Reset Drawing has no effect. It is only used to perform the reset
operation.<br /><br />



<h1><a name="vipmiscregisters">VIP Miscellaneous Registers</a></h1>

<b>0x0005F82E - Frame Repeat (W)</b><br />
<pre class="indent">
Bits 15-4   Not used
Bits  3-0   Repeat Count
</pre>

This register controls how many display frames elapse before the
<a href="#vipdrawingprocedure">VIP Drawing Procedure</a> occurs. Add 1 to this
value to specify the number of display frames.<br /><br />

To suspend drawing indefinitely, simply disable it in
<a href="#vipdrawingregisters">Drawing Control</a>.<br /><br />

<b>0x0005F844 - Version (R)</b><br />
<pre class="indent">
Bits 15-5   Not used
Bits  4-0   Version
</pre>

Indicates the hardware version of the VIP, which can be used to determine what
features are available. There was only ever one model of the Virtual Boy
produced, and its version is 2.<br /><br />



<h1><a name="virtualsoundunitvsu">Virtual Sound Unit (VSU)</a></h1>

<b>Overview</b><br />
<a href="#vsuoverview">VSU Overview</a><br/ >
<a href="#vsumemorymap">VSU Memory Map</a><br />
<a href="#vsugenerationprocedure">VSU Generation Procedure</a><br />
<a href="#vsumastercontrol">VSU Master Control</a><br />
</br >

<b>Channel Features</b><br />
<a href="#vsupcmwaveforms">VSU PCM Waveforms</a><br />
<a href="#vsuplaycontrol">VSU Play Control</a><br />
<a href="#vsuvolume">VSU Volume</a><br />
<a href="#vsufrequency">VSU Frequency</a><br />
<a href="#vsuenvelope">VSU Envelope</a><br />
<a href="#vsusweepandmodulation">VSU Sweep &amp; Modulation</a><br />
<a href="#vsunoisegenerator">VSU Noise Generator</a><br />
<br />



<h1><a name="vsuoverview">VSU Overview</a></h1>

The Virtual Boy's sound unit has 5 wave channels and a noise channel. The
system has two built-in stereo speakers, a volume wheel, and a headphone
jack.<br /><br />

Channels 1 through 4 are standard wave channels. Channel 5 contains all of the
functionality of the standard wave channels, as well as support for frequency
sweep and modulation. The sixth channel is a noise generator.<br /><br />

Wave generation is performed by writing 32 PCM samples to VSU memory and those
samples are used to produce the output waves.<br /><br />

Audio output is 10-bit stereo at 41700 hz.<br /><br />




<h1><a name="vsumemorymap">VSU Memory Map</a></h1>

<i>Editor's Note: Is the VSU memory range mirrored at all?</i><br /><br />

<b>VSU Memory Map</b><br />
<pre class="indent">
0x01000000-0x0100007F   PCM Wave Table 0
0x01000080-0x010000FF   PCM Wave Table 1
0x01000100-0x0100017F   PCM Wave Table 2
0x01000180-0x010001FF   PCM Wave Table 3
0x01000200-0x0100027F   PCM Wave Table 4
0x01000280-0x010002FF   Modulation Table
<b>0x01000400-0x010005FF</b>   <b>VSU Control Registers</b> (See below)
</pre>

<a name="vsucontrolregisters"><b>VSU Control Registers</b></a><br />
<pre class="indent">
0x01000400 - Channel 1 Play Control
0x01000404 - Channel 1 Volume
0x01000408 - Channel 1 Frequency Low
0x0100040C - Channel 1 Frequency High
0x01000410 - Channel 1 Envelope Data
0x01000414 - Channel 1 Envelope Control
0x01000418 - Channel 1 PCM Wave

0x01000440 - Channel 2 Play Control
0x01000444 - Channel 2 Volume
0x01000448 - Channel 2 Frequency Low
0x0100044C - Channel 2 Frequency High
0x01000450 - Channel 2 Envelope Data
0x01000454 - Channel 2 Envelope Control
0x01000458 - Channel 2 PCM Wave

0x01000480 - Channel 3 Play Control
0x01000484 - Channel 3 Volume
0x01000488 - Channel 3 Frequency Low
0x0100048C - Channel 3 Frequency High
0x01000490 - Channel 3 Envelope Data
0x01000494 - Channel 3 Envelope Control
0x01000498 - Channel 3 PCM Wave

0x010004C0 - Channel 4 Play Control
0x010004C4 - Channel 4 Volume
0x010004C8 - Channel 4 Frequency Low
0x010004CC - Channel 4 Frequency High
0x010004D0 - Channel 4 Envelope Data
0x010004D4 - Channel 4 Envelope Control
0x010004D8 - Channel 4 PCM Wave

0x01000500 - Channel 5 Play Control
0x01000504 - Channel 5 Volume
0x01000508 - Channel 5 Frequency Low
0x0100050C - Channel 5 Frequency High
0x01000510 - Channel 5 Envelope Data
0x01000514 - Channel 5 Envelope/Sweep/Modulation Control
0x01000518 - Channel 5 PCM Wave
0x0100051C - Channel 5 Sweep/Modulation Data

0x01000540 - Noise Channel Play Control
0x01000544 - Noise Channel Volume
0x01000548 - Noise Channel Frequency Low
0x0100054C - Noise Channel Frequency High
0x01000550 - Noise Channel Envelope Data
0x01000554 - Noise Channel Envelope/Noise Control

0x01000580 - Sound Disable
</pre>

All VSU control registers are 8 bits wide and should be accessed by
byte.<br /><br />



<h1><a name="vsugenerationprocedure">VSU Generation Procedure</a></h1>

The procedure for producing audio on the Virtual Boy is as follows. This
section describes the operations of the hardware and it is not necessary that
this exact algorithm be used to produce sound. It is documented here for the
sake of completeness.<br /><br />

<a name="vsuvolumegeneration"><b>Volume Generation</b></a><br /><br />

Volume levels are generated for each sound channel, as well as for each of the
left and right stereo output channels. The volume generation for one output
channel (left/right) for one sound channel is as follows:<br /><br />

<div class="indent">
&bull; The 4-bit <a href="#vsuvolume">volume</a> value is multiplied by the
current 4-bit <a href="#vsuenvelope">envelope</a> value.<br />
&bull; Of the resulting 8 bits, only the upper 5 bits are used as the output
volume.<br />
&bull; If the output volume is not 0, 1 is added to it.<br />
</div><br />

<a name="vsusamplegeneration"><b>Sample Generation</b></a><br /><br />

A sample, either from the <a href="#vsupcmwaveforms">PCM waveforms</a> or from
the <a href="#vsunoisegenerator">noise generator</a>, is read in as a 6-bit
value according to the sweep, modulation and noise specifications. It is then
processed as follows, for each of the left and right output channels
independently:<br /><br />

<div class="indent">
&bull; The 6-bit sample is multiplied by the 5-bit volume value calculated in
the Volume Generation procedure.<br />
&bull; Of the resulting 11 bits, only the upper 10 are used.<br />
&bull; The 10-bit values for all samples are added together.<br />
&bull; Of the resulting 13-bit value, only the upper 10 are used as
output.<br />
</div><br />

The output sample rate is 41700 hz before being converted to an analog
signal.<br /><br />



<h1><a name="vsumastercontrol">VSU Master Control</a></h1>

<b>0x01000580 - Sound Disable (W)</b><br />
<pre class="indent">
Bits 7-1   Not used
Bit  0     Stop Sound
</pre>

Setting Stop Sound to 1 will stop any sound channels currently generating
sound. <i>Editor's Note: Is this an action bit, or does it need to be set to 0
again before sounds can be used?</i><br /><br />



<h1><a name="vsupcmwaveforms">VSU PCM Waveforms</a></h1>

Wave generation on the VSU is performed by reading samples from PCM wave
memory. There are five wave tables, each with 32 samples.<br />

<pre class="indent">
0x01000000-0x0100007F   PCM Wave Table 0
0x01000080-0x010000FF   PCM Wave Table 1
0x01000100-0x0100017F   PCM Wave Table 2
0x01000180-0x010001FF   PCM Wave Table 3
0x01000200-0x0100027F   PCM Wave Table 4
</pre>

Samples are accessed on word boundaries, but only the 6 least significant bits
are used. Samples are unsigned: 0 is the minimum value and 63 is the maximum
value.<br /><br />

All 32 samples of a PCM wave table represent one cycle of the wave. To sample
all 32 samples <i>n</i> times per second is to produce an <i>n</i> hz
wave.<br /><br />

PCM wave table memory can only be written while all sound channels are
inactive.<br /><br />

<i>Editor's Note: Is PCM wave memory read/write or write-only?</i><br /><br />


<b>0x01000418 - Channel 1 PCM Wave (W)<br />
0x01000458 - Channel 2 PCM Wave (W)<br />
0x01000498 - Channel 3 PCM Wave (W)<br />
0x010004D8 - Channel 4 PCM Wave (W)<br />
0x01000518 - Channel 5 PCM Wave (W)</b><br />
<pre class="indent">
Bits 7-3   Not used
Bits 2-0   Wave Index
</pre>

The Wave Index field specifies which PCM wave table (0-4) to use on this sound
channel. <i>Editor's Note: What happens if you specify 5 or 6?</i><br /><br />



<h1><a name="vsuplaycontrol">VSU Play Control</a></h1>

<b>0x01000400 - Channel 1 Play Control (W)<br />
0x01000440 - Channel 2 Play Control (W)<br />
0x01000480 - Channel 3 Play Control (W)<br />
0x010004C0 - Channel 4 Play Control (W)<br />
0x01000500 - Channel 5 Play Control (W)<br />
0x01000540 - Noise Channel Play Control (W)</b><br />
<pre class="indent">
Bit  7     Enable Channel
Bit  6     Not used
Bit  5     Use Duration
Bits 4-0   Duration
</pre>

Setting Enable Channel to 1 will activate the sound channel and begin
generating sound. Setting it to 0 will immediately stop sound generation on
the channel.<br /><br />

Setting Use Duration to 1 will cause the channel to automatically
deactivate after the specified duration has elapsed. Setting this bit to 0 will
cause the channel to generate sound indefinitely until deactivated by some
other means.<br /><br />

Duration specifies how long the channel should generate sound before
automatically shutting itself off, in units of 260.4 Hz (&#x2248; 38.402
milliseconds). Add 1 to this value for the actual duration
specifier.<br /><br />

<i>Editor's Note: This whole business with duration is being interpreted
correctly, right?</i><br /><br />



<h1><a name="vsuvolume">VSU Volume</a></h1>

Sound channel levels can be adjusted individually for both the left and right
output channels.<br /><br />

<b>0x01000404 - Channel 1 Volume (W)<br />
0x01000444 - Channel 2 Volume (W)<br />
0x01000484 - Channel 3 Volume (W)<br />
0x010004C4 - Channel 4 Volume (W)<br />
0x01000504 - Channel 5 Volume (W)<br />
0x01000544 - Noise Channel Volume (W)</b><br />
<pre class="indent">
Bits 7-4   Left Volume
Bits 3-0   Right Volume
</pre>

Left Volume controls the channel for the left output channel, and Right Volume
controls the right channel. The minimum value is 0, which specifies silence,
and the maximum value is 15.<br /><br />



<h1><a name="vsufrequency">VSU Frequency</a></h1>

The input sample rate for all sound channels is variable. All frequency values
are 11 bits in size.<br /><br />

<b>0x01000408 - Channel 1 Frequency Low (W)<br />
0x01000448 - Channel 2 Frequency Low (W)<br />
0x01000488 - Channel 3 Frequency Low (W)<br />
0x010004C8 - Channel 4 Frequency Low (W)<br />
0x01000508 - Channel 5 Frequency Low (W)<br />
0x01000548 - Noise Channel Frequency Low (W)</b><br />
<pre class="indent">
Bits 7-0   Data
</pre>

<b>
0x0100040C - Channel 1 Frequency High (W)<br />
0x0100044C - Channel 2 Frequency High (W)<br />
0x0100048C - Channel 3 Frequency High (W)<br />
0x010004CC - Channel 4 Frequency High (W)<br />
0x0100050C - Channel 5 Frequency High (W)<br />
0x0100054C - Noise Channel Frequency High (W)</b><br />
<pre class="indent">
Bits 7-3   Not used
Bits 2-0   Data
</pre>

The Frequency registers modify the sound channel's input sampling rate. Samples
read from <a href="#vsupcmwaveforms">PCM waveforms</a> or from the
<a href="#vsunoisegenerator">noise generator</a> are produced at the specified
frequency, which allows different tones to be generated.<br /><br />

<a name="vsupcmwaveformsamplerate"><b>PCM Waveform Sample
Rate</b></a><br /><br />

When PCM waveforms are sampled, the value of the Frequency registers is used
to calculate the sampling rate with the following formula:<br /><br />

<div class="indent">
PCM_Rate = 5,000,000 hz / ((2,048 - <i>Frequency</i>) * 32)
</div><br />

The minimum Frequency value for PCM waveforms is 0 (&#x2248; 76.29 hz), and the
maximum value is 2,040 (&#x2248; 19,531.25 hz). <i>Editor's Note: What happens
if you specify a higher frequency? Specifying even 2047 gives the
astronomically high frequency of 156,250.0 hz, so perhaps the hardware won't
accept them.</i><br /><br />

<a name="vsunoisesamplerate"><b>Noise Sample Rate</b></a><br /><br />

When noise is sampled, the value of the Frequency registers is used to
calculate the sampling rate with the following formula:<br /><br />

<div class="indent">
Noise_Rate = 500,000 hz / (2,048 - <i>Frequency</i>)
</div><br />

The minimum Frequency value for noise is 0 (&#x2248; 244.14 hz) and the
maximum value is 2,047 (= 500,000.00 hz).<br /><br />



<h1><a name="vsuenvelope">VSU Envelope</a></h1>

The envelope function of sound channels allows their volume to decay over
time.<br /><br />

<b>
0x01000414 - Channel 1 Envelope Control (W)<br />
0x01000454 - Channel 2 Envelope Control (W)<br />
0x01000494 - Channel 3 Envelope Control (W)<br />
0x010004D4 - Channel 4 Envelope Control (W)<br />
0x01000514 - Channel 5 Envelope/Sweep/Modulation Control* (W)<br />
0x01000554 - Noise Channel Envelope/Noise Control* (W)</b><br />
<pre class="indent">
Bits 7-2   Not used*
Bit  1     Repeat Envelope
Bit  0     Enable Envelope
</pre>

* - The Channel 5 and Noise registers have additional bits not pertinent to
envelope control. For more information, see
<a href="#vsusweepandmodulation">VSU Sweep &amp; Modulation</a> and
<a href="#vsunoisegenerator">VSU Noise Generator</a>.<br /><br />

When Repeat Envelope is set to 1, and the envelope reaches 0, the envelope will
be reset to its Reload Value and the cycle will repeat. When Repeat Envelope is
set to 0, the envelope will remain at 0 once it reaches it.<br /><br />

Setting Enable Envelope to 1 will activate the envelope function, even while
the channel is currently generating sound. Setting this bit to 0 will disable
the envelope.<br /><br />

<b>0x01000410 - Channel 1 Envelope Data (W)<br />
0x01000450 - Channel 2 Envelope Data (W)<br />
0x01000490 - Channel 3 Envelope Data (W)<br />
0x010004D0 - Channel 4 Envelope Data (W)<br />
0x01000510 - Channel 5 Envelope Data (W)<br />
0x01000550 - Noise Channel Envelope Data (W)</b><br />
<pre class="indent">
Bits 7-4   Reload Value
Bit  3     Direction
Bits 2-0   Step Interval
</pre>

Reload Value specifies the initial envelope value as well as the value it loads
when repeating. When set, the envelope is immediately set to this value. 0
represents silence and 15 represents full volume.<br /><br />

Direction specifies the direction in which the envelope moves:<br /><br />

<div class="indent">
0 - Envelope will decrease (decay) over time.<br />
1 - Envelope will increase (grow) over time.<br />
</div><br />

In both cases, the envelope period ends when the envelope value reaches 0. For
a growth period, this happens the next step after the value becomes
15.<br /><br />

Step Interval specifies how long each envelope value will last, in units of
65.1 hz (&#x2248; 15.361 milliseconds). Add 1 to this value for the actual
duration amount.<br /><br />



<h1><a name="vsusweepandmodulation">VSU Sweep &amp; Modulation</a></h1>

Channel 5 has, in addition to all of the features of Channels 1-4, support for
frequency sweep and modulation functions. Frequency modifications are made
directly to the <a href="#vsufrequency">frequency registers</a>.<br /><br />

<b>0x01000514 - Channel 5 Envelope/Sweep/Modulation Control (W)</b><br />
<pre class="indent">
Bit  7     Not used
Bit  6     Enable Sweep/Modulation
Bit  5     Repeat Modulation
Bit  4     Function
Bits 3-0   Not used*
</pre>

* - This register has additional bits not pertinent to sweep or modulation. For
more information, see <a href="#vsuenvelope">VSU Envelope</a>.<br /><br />

Setting Enable Sweep/Modulation to 1 will activate the frequency modification
feature of the channel. Setting this bit to 0 will deactivate the
feature.<br /><br />

When Repeat Modulation is set to 1, the modulation samples will be read from
the Modulation Table repeatedly. When this bit is 0, the modulation samples
will be read once and the channel will continue with the last-read
frequency.<br /><br />

Function specifies which frequency modification function to use:<br /><br />

<div class="indent">
0 - Sweep<br />
1 - Modulation<br />
</div><br />

<b>0x0100051C - Channel 5 Sweep/Modulation Data (W)</b><br />
<pre class="indent">
Bit  7     Modification Base Interval
Bits 6-4   Modification Interval
Bit  3     Sweep Direction
Bits 2-0   Sweep Amount
</pre>

The Modification Base Interval specifies the base frequency used by frequency
modification functions:<br /><br />

<div class="indent">
0 - 1041.6 hz (&#x2248; 0.96 milliseconds)<br />
1 - 130.2 hz (&#x2248; 7.68 milliseconds)<br />
</div><br />

The integer value in Modification Interval is multiplied by the specified
Modification Base Interval frequency to resolve the actual interval between
frequency modifications.<br /><br />

If Modification Interval is 0, then frequency modification will not be
performed.<br /><br />

For either frequency modificaiton function, if the frequency drops below 0 or
rises above 2040, sound generation on channel 5 will be stopped.<br /><br />

<span class="br"></span>

<a name="vsusweep"><b>Sweep</b></a><br /><br />

When using the sweep function, the frequency of sound channel 5 is modified
over time algorithmically.<br /><br />

Sweep Direction specifies whether the frequency will change in an upward or
downward direction:<br /><br />

<div class="indent">
0 - Sweep Amount is subtracted from the channel frequency<br />
1 - Sweep Amount is added to the channel frequency<br />
</div><br />

At the interval specified by Modification Base Interval and Modification
Interval, sound channel 5's Frequency registers will be modified by +/- Sweep
Amount, depending on the value of Sweep Direction.<br /><br />

<a name="vsumodulation"><b>Modulation</b></a><br /><br />

In addition to the values in the Channel 5 Sweep/Modulation Data register,
sample memory exists for reading modulation data:<br />

<pre class="indent">
0x01000280-0x010002FF   Modulation Table
</pre>

Like the <a href="#vsupcmwaveforms">PCM waveforms</a>, the modulation samples
are accessed as words, and there are 32 of them. Modulation samples have a
different binary format, however: modulation samples are 8 bits, and signed
(two's complement).<br /><br />

At the interval specified by Modification Base Interval and Modification
Interval, sound channel 5's Frequency registers will be modified by the next
modulation sample, according to the setting of Repeat Modulation.<br /><br />

Modulation table memory can only be written while all sound channels are
inactive.<br /><br />



<h1><a name="vsunoisegenerator">VSU Noise Generator</a></h1>

The Virtual Boy noise generator is a 15-bit linear feedback shift register with
a configurable tap location. Output is binary: noise is only either high or
low.<br /><br/ >

<b>0x01000554 - Noise Channel Envelope/Noise Control (W)</b><br />
<pre class="indent">
Bit  7     Not used
Bits 6-4   Tap Location
Bits 3-0   Not used*
</pre>

* - This register has additional bits not pertinent to noise generation. For
more information, see <a href="#vsuenvelope">VSU Envelope</a>.<br /><br />

Tap Location specifies the bit within the shift register to use as the feedback
source in noise generation. Different bits will produce pseudorandom bit
sequences of different lengths before the sequences repeat. The bit positions
were selected by the hardware designer and sorted in descending order of
sequence length:<br /><br />

<div class="indent">
0 - Bit 14 - Sequence length of 32767<br />
1 - Bit 10 - Sequence length of 1953<br />
2 - Bit 13 - Sequence length of 254<br />
3 - Bit 4 - Sequence length of 217<br />
4 - Bit 8 - Sequence length of 73<br />
5 - Bit 6 - Sequence length of 63<br />
6 - Bit 9 - Sequence length of 42<br />
7 - Bit 11 - Sequence length of 28<br />
</div></i><br />

At the interval specified in the <a href="#vsufrequency">Frequency
registers</a>, a single bit is produced by the noise generator. The bit is then
scaled to 6 bits to be the same size as the samples of the other sound
channels. That is to say, if a 0 is generated, the sample is 0; and if a 1 is
generated, the sample is 63.<br /><br />

<a name="vsunoisealgorithm"><b>Algorithm</b></a><br /><br />

The shift register is 15 bits wide and is initialized to all 1s. When a bit is
produced as noise, two bits from the shift register are XORed together. One of
the bits is bit 7, and the other bit is the bit specified by Tap Location. The
inverse of the result (0 becomes 1 and vice/versa) is used as the output. The
entire register is then shifted to the left one bit, and the result of the
earlier XOR operation (not inverted) becomes the new bit 0.<br /><br />

<i>Editor's Note: When is the shift register seeded to all 1s? When the Noise
Control register is written?</i><br /><br />



<h1><a name="hardwarecontrolregisters">Hardware Control Registers</a></h1>


<b>Hardware Control Registers</b><br />
<a href="#hardwarecontrolmemorymap">Hardware Control Memory Map</a><br />
<a href="#hardwarelinkport">Hardware Link Port</a><br />
<a href="#hardwaregamepad">Hardware Game Pad</a><br />
<a href="#hardwaretimer">Hardware Timer</a><br />
<a href="#hardwarewaitcontroller">Hardware Wait Controller</a><br />
<br />



<h1><a name="hardwarecontrolmemorymap">Hardware Control Memory Map</a></h1>

All hardware control registers are 8 bits wide and should be accessed by
byte.<br /><br />

<i>Editor's Note: Is the hardware control memory range mirrored at
all?</i><br /><br />

<b>Hardware Control Memory Map</b><br />
<pre class="indent">
0x02000000 - Link Control Register
0x02000004 - Auxiliary Link Register
0x02000008 - Link Transmit Data
0x0200000C - Link Receive Data
0x02000010 - Game Pad Input Low
0x02000014 - Game Pad Input High
0x02000018 - Timer Counter/Reload Low
0x0200001C - Timer Counter/Reload High
0x02000020 - Timer Control Register
0x02000024 - Wait Control Register
0x02000028 - Game Pad Input Control Register
</pre>

Addresses from 0x02000000 through 0x02FFFFFF other than the ones listed above
do not have any behavior associated with them.<br /><br />



<h1><a name="hardwarelinkport">Hardware Link Port</a></h1>

The link port on the Virtual Boy is used for communications between two
systems. No link cable was ever manufactured for Virtual Boy, and no commercial
games are known to support communications.<br /><br />

The link port contains 8 pins and is keyed. The following diagram depicts the
link port, looking into the socket from the bottom of the Virtual Boy
unit:<br />

<pre class="indent">
  ____________
 /            \
|  1  2  3  4  |
| ============ |
|  5  6  7  8  |
'--------------'
</pre>

<i>Editor's Note: The following description of pin connections may not be 100%
accurate.</i><br /><br />

When linking pins with a link cable, the following connections need to be
made:<br /><br />

<div class="indent">
Pin 1 -> Pin 1<br />
Pin 2 -- Not connected<br />
Pin 3 -> Pin 3<br />
Pin 4 -> Pin 8<br />
Pin 5 -- Not connected<br />
Pin 6 -> Pin 6<br />
Pin 7 -> Pin 7<br />
Pin 8 -> Pin 4<br />
</div><br />

<b>0x02000000 - Link Control Register (R/W, with exceptions)</b><br />
<pre class="indent">
Bit  7     R/W   Disable Link Interrupt
Bits 6-5   ---   Not used
Bit  4     R/W   Clock Select
Bit  3     ---   Not used
Bit  2      W    Transmit/Receive
Bit  1      R    Communication Status
Bit  0     ---   Not used
</pre>

Setting Disable Link interrupt to 1 will prevent Link
<a href="#cpuexceptionsandinterrupts">interrupt</a> from being raised. When
enabled, Link interrupts occur after a communication completes. Link interrupts
have an exception code of 0xFE30 and branch CPU execution to address
0xFFFFFE30.<br /><br />

Clock Select is used to determine the clock source for communications. One
Virtual Boy system must be configured as a master, and the other as slave. The
master will transmit the clock signal, and the slave will listen for
it.<br /><br />

<div class="indent">
&bull; 0 - Internal clock (master)<br />
&bull; 1 - External clock (slave)<br />
</div><br />

Setting Transmit/Receive to 1 will initiate a communication between Virtual Boy
systems. Both systems must set this bit in order for communication to occur.
Additionally, both systems will transmit and receive data simultaneously.
Setting this bit to 0 has no effect; it is only used to perform the
communication operation.<br /><br />

Communication Status will be set to 1 during communication, and 0 when the link
is idle.<br /><br />

<b>0x02000008 - Link Transmit Data (W/R)<br />
0x0200000C - Link Receive Data (R)</b><br />
<pre class="indent">
Bits 7-0   Data
</pre>

These 8-bit registers are used to store and retrieve data to be sent and
received during a link communication, respectively. Link Transmit Data must be
set prior to transmission, and Link Receive Data should not be read before
communication completes. Communication status can be determined with the Link
Control Register.<br /><br />

<span class="br"></span>

<b>0x02000004 - Auxiliary Link Register (R/W, with exceptions)</b><br />
<pre class="indent">
Bit  7     R/W   Disable Link Interrupt
Bits 6-5   ---   Not used
Bit  4     R/W   Interrupt Compare
Bit  3     R/W   Aux Transmit Data
Bit  2      R    Aux Receive Data
Bit  1     R/W   Enable Aux Link
Bit  0      R    Aux Link Status
</pre>

<i>Editor's Note: This register is not well understood. Information in this
section may not be 100% accurate.</i><br /><br />

The Auxiliary Link optionally sends 1 bit of information between Virtual Boy
systems upon completion of a data communication as performed with the Link
Control Register. The value of the Aux bit can be automatically checked against
the configuration of this register to raise a Link interrupt. As with the Link
Control Register, Link intererupts raised by the Auxiliary Link Register also
have an exception code of 0xFE30 and branch CPU execution to address
0xFFFFFE30.<br /><br />

Setting Disable Link Interrupt to 1 will prevent Link interrupts from being
raised by the Auxiliary Link.<br /><br />

Interrupt Compare stores the value to check received Aux data against to
determine whether to raise a Link interrupt. If Aux Receive Data matches
Interrupt Compare, and Aux Link interrupts are enabled, a Link interrupt will
be raised.<br /><br />

Aux Transmit Data contains the value to send on the Aux Link when a normal Link
communication completes.<br /><br />

Aux Receive Data contains the value received on the Aux Link when a normal Link
communication comletes.<br /><br />

<i>Editor's Note: The function and significance of Aux Link Status is not
apparent at this time. Perhaps it's set when the 1 Aux bit is being
transmitted?</i><br /><br />



<h1><a name="hardwaregamepad">Hardware Game Pad</a></h1>

The Virtual Boy has an 8-direction, 6-buton game pad that also supplies power
to the system. It was manufactured with a battery pack that accepted 6 AA
batteries, and an A/C Adapter was also manufactured and sold
separately.<br /><br />

<b>0x02000028 - Game Pad Input Control Register (R/W, with
exceptions)</b><br />
<pre class="indent">
Bit 7   R/W   Game Pad Interrupt Disable
Bit 6   ---   Not used
Bit 5   R/W   Latch Game Pad Signal
Bit 4   R/W   Software Input Clock Signal
Bit 3   ---   Not used
Bit 2    W    Initiate Hardware Read
Bit 1    R    Hardware Input in Progress
Bit 0   R/W   Abort Hardware Read
</pre>

Setting Game Pad Interrupt Disable to 1 will prevent Game Pad
<a href="#cpuexceptionsandinterrupts">interrupt</a> from being raised. It must
also be set in the interrupt handler to acknowledge the interrupt. Game Pad
interrupts have an exception code of 0xFE00 and branch CPU execution to address
0xFFFFFE00.<br /><br />

The Latch Game Pad Signal primes the game pad for software input reads. This
bit must be set to 1 before any input is read by software, and set to 0 during
software or hardware input reads.<br /><br />

Software Input Clock Signal sends read signals to the game pad. The bits
actually sent to the game pad are the opposite of the bits written to this
register:<br /><br />

<div class="indent">
0 - Sends a 1 to the game pad<br />
1 - Sends a 0 to the game pad<br />
</div><br />

To perform a software read, bits need to be sent to the game pad in the order
of 0 followed by 1. This needs to occur 16 times: one for each bit in the Game
Pad Input registers (for a total of 32 writes). The first bit sent to the game
pad must be a 0, and must be sent after the Latch Game Pad signal. If the Game
Pad Input registers are read before all 16 bits of input have been processed,
the data will be junk and may not reflect the actual state of the game pad
buttons.<br /><br />

Initiate Hardware Read will perform the latch and clock operations
automatically by the hardware. A single input read will be performed. The rate
at which the hardware reads game pad input is slower than can be done with a
software read. However, if enabled, a Game Pad interrupt can be raised. If
enabled, a Game Pad interrupt will be raised if any bit in the Game Pad Input
registers is read as a 1, with the exception of the following:<br /><br />

<div class="indent">
&bull; A button<br />
&bull; B button<br />
&bull; The "always 1" bit from the standard controller<br />
</div><br />

If all other bits are 0, a Game Pad interrupt will not be raised. Setting
Initiate Hardware Read to 0 has no effect; it is only used to initiate the
hardware game pad input read process.<br /><br />

Hardware Input in Progress will be set to 1 while a hardware read is being
performed, and 0 when no hardware game pad input read is in
progress. If the Game Pad Input registers are read while this bit is set, the
data will be junk and may not reflect the actual state of the game pad
buttons.<br /><br />

Abort Hardware Read will abort any hardware game pad input reading currently in
progress, and no interrupt will be raised. If Initiate Hardware Read is
specified in the same write as Abort Hardware Read, no hardware game pad input
read will occur.<br /><br />

<span class="br"></span>

<b>0x02000010 - Game Pad Input Low (R)</b><br />
<pre class="indent">
Bit 7   Right D-Pad Right
Bit 6   Right D-Pad Up
Bit 5   L Button
Bit 4   R Button
Bit 3   B Button
Bit 2   A Button
Bit 1   Always 1
Bit 0   Low Battery
</pre>

<b>0x02000014 - Game Pad Input High (R)</b><br />
<pre class="indent">
Bit 7   Right D-Pad Down
Bit 6   Right D-Pad Left
Bit 5   Select Button
Bit 4   Start Button
Bit 3   Left D-Pad Up
Bit 2   Left D-Pad Down
Bit 1   Left D-Pad Left
Bit 0   Left D-Pad Right
</pre>

The game pad will transmit input status to these two registers during a game
pad input read. When a button is pressed (or the battery voltage is low), the
corresponding bit will be 1. Otherwise, the bit will be 0.<br /><br />

Neither of these registers should be accessed before all 16 bits of input have
been read from the game pad.<br /><br />



<h1><a name="hardwaretimer">Hardware Timer</a></h1>

A high-frequency hardware timer exists in the Virtual Boy that can be used by
programs to perform accurate timing of activities. The timer is a 16-bit value
that counts down by 1 each tick, and reloads a preset value once it reaches
0.<br /><br />

<b>0x02000020 - Timer Control Register (R/W, with exceptions)</b><br />
<pre class="indent">
Bits 7-5   ---   Not used
Bit  4     R/W   Tick Interval
Bit  3     R/W   Enable Timer Zero Interrupt
Bit  2      W    Clear Timer Zero Status
Bit  1      R    Timer Zero Status
Bit  0     R/W   Enable Timer
</pre>

Tick Interval configures the amount of time between timer ticks:<br /><br />

<div class="indent">
&bull; 0 - 100 microseconds per tick<br />
&bull; 1 - 20 microseconds per tick<br />
</div><br />

A microsecond is one millionth of a second. This bit can be updated while
Enable Timer is set. <i>Editor's Note: One source discourages changing the tick
interval while the timer is enabled, but testing has shown that it
works.</i><br /><br />

Setting Enable Timer Zero Interrupt to 1 will allow Timer Zero
<a href="#cpuexceptionsandinterrupts">interrupt</a> to be raised when Timer
Zero Status becomes set. Timer Zero interrupts have an exception code of 0xFE10
and branch CPU execution to 0xFFFFFE10. <i>Editor's Note: Will the interrupt be
raised only when the timer counts down from 1, or whenever the timer is
zero?</i><br /><br />

Setting Clear Timer Zero Status to 1 resets the Timer Zero Status bit and
acknowledges Timer Zero interrupts. The Timer Zero interrupt handler must first
set Enable Timer Zero Interrupt to 0, then set Clear Timer Zero to 1 in order
to acknowledge the interrupt. Due to this, the Timer Zero interrupt handler
must re-enable the timer in order for future interrupts to be raised. Setting
this bit to 0 will have no effect; its only purpose is to clear the Timer Zero
Status bit.<br /><br />

Timer Zero Status will be set to 1 when the timer reaches 0. This must be
cleared by setting Clear Timer Zero Status to 1 while the timer is disabled.
<i>Editor's Note: If this flag is not cleared, will the timer remain at
0?</i><br /><br />

Setting Enable Timer to 1 will activate the timer and it will begin to count
down from its most recent count value. Setting this bit to 0 will stop the
timer.<br /><br />

<b>0x02000018 - Timer Counter/Reload Low (R/W)<br />
0x0200001C - Timer Counter/Reload High (R/W)</b><br />
<pre class="indent">
Bits 7-0   Timer Counter (R)/Timer Reload Value (W)
</pre>

Reading from these registers will return the current counter value. Take care
when reading these registers while the timer is active, as it's possible to
construct an improper result due to timer operations between reads.<br /><br />

Writing to these registers will specify a new value for the timer to reload
after it reaches 0. Writing to either of these registers will load all 16 bits
of the timer's reload value to the timer's current count.<br /><br />



<h1><a name="hardwarewaitcontroller">Hardware Wait Controller</a></h1>

<b>0x02000024 - Wait Control Register (R/W)</b><br />
<pre class="indent">
Bits 7-2   Not used
Bit  1     Cartridge Expansion Waits
Bit  0     Cartridge ROM Waits
</pre>

Both bits of this register have the same configuration values:<br /><br />

<div class="indent">
&bull; 0 - 2 waits<br />
&bull; 1 - 1 wait<br />
</div><br />

The internal wait controller will generate bus waits for hardware components.
Cartridge waits can be configured if high-speed cartridge hardware is
available. Commercial games set Cartridge ROM Waits to 1 wait, and no
commercial game uses the Cartridge Expansion addresses.<br /><br />



<h1><a name="cpuv810familymicroprocessor">CPU V810 Family
Microprocessor</a></h1>

The Virtual Boy uses a modified NEC V810 CPU called the NVC that operates at
20.0 MHz. A handful of instructions were added by Nintendo.</i><br /><br />

<b>Overview</b><br />
<a href="#cpuregistersandflags">CPU Registers and Flags</a><br />
<a href="#cpudatatypesandconventions">CPU Data Types and Conventions</a><br />
<a href="#cpuexceptionsandinterrupts">CPU Exceptions &amp; Interrupts</a><br />
<a href="#cpucachedumpandrestore">CPU Cache Dump &amp; Restore</a><br />
<a href="#cpulistofexceptions">CPU List of Exceptions</a><br />
<br />

<b>Instruction Set</b><br />
<a href="#cpuinstructionformats">CPU Instruction Formats</a><br />
<a href="#cpumemoryandregistertransfers">CPU Memory and Register
Transfers</a><br />
<a href="#cpuarithmeticbitwiseoperations">CPU Arithmetic/Bitwise
Operations</a><br />
<a href="#cpujumpandcontrolinstructions">CPU Jump and Control
Instructions</a><br />
<a href="#cpufloatingpointinstructions">CPU Floating-Point
Instructions</a><br />
<a href="#cpubitstringinstructions">CPU Bit String Instructions</a><br />
<a href="#cpumiscinstructions">CPU Miscellaneous Instructions</a><br />
<a href="#cpunintendoinstructions">CPU Nintendo Instructions</a><br />
<br />

<b>Other Info</b><br />
<a href="#cpuinstructionsbyopcode">CPU List of Instructions by
Opcode</a><br />
<a href="#cpuinstructionsbymnemonic">CPU List of Instructions by
Mnemonic</a><br />
<a href="#cpuinstructionsbyformat">CPU List of Instructions by
Format</a><br />

<br />



<h1><a name="cpuregistersandflags">CPU Registers and Flags</a></h1>

The NEC V810 family contains 32 general-purpose program registers, ten system
registers and a program counter. All registers are 32 bits wide.<br /><br />

<a name="cpuprogramregisters"><b>Program Registers</b></a><br /><br />

The program registerscan be used for any purpose by the program and will not be
modified by the system except under specific circumstances initiated by the
program. There are 32 program registers, called r0 through r31. While most of
them are only used by the program for storage and data processing, a few of
them do have special significance:<br />

<ul>
<li>r0 - Has a fixed value of zero and cannot be used to store data.</li>
<li>r26 - Used for input with bit string instructions. Contains the bit offset
within the destination word.</li>
<li>r27 - Used for input with bit string instructions. Contains the bit offset
within the source word.</li>
<li>r28 - Used for input with bit string instructions. Contains the remaining
length of the bit string, in bits.</li>
<li>r29 - Used for input and output with bit string instructions.
  <ul>
  <li>Input - For arithmetic instructions, contains the address of the
  destination word.</li>
  <li>Output - For search instructions, contains the number of bits scanned
  before a match was found. Should be initialized to zero before use.</li>
  </ul>
</li>
<li>r30 - Used for input with the <i>CAXI</i> and bit string instructions, and
stores output from integer multiply and divide instructions.<br />
  <ul>
  <li>Input - For bit string instructions, contains the address of the source
  word.</li>
  <li>Input - For the <i>CAXI</i> instruction, contains the value to exchange
  with the lock word.</li>
  <li>Output - For the <i>MUL</i> and <i>MULU</i> instructions, contains the
  upper 32 bits of the product.</li>
  <li>Output - For the <i>DIV</i> and <i>DIVU</i> instructions, contains the
  remainder of the division.</li>
  </ul>
</li>
<li>r31 - Link pointer. Contains the return address after the <i>JAL</i>
instruction is used.</li>
</ul>

<a name="cpupcprogramcounter"><b>PC - Program Counter</b></a><br /><br />
The program counter (PC) represents the address of the <i>current</i>
instruction being executed. Its lowest bit is fixed to 0, meaning it can only
reference addresses on a halfword boundary (only even addresses).<br /><br />

PC is normally incremented by the CPU by the number of bytes in the instruction
<i>after</i> execution, but can be set by the program by using a jump
instruction</a>. When used with a relative jump instruction, a displacement
value of 0 refers to the jump instruction itself: incrementation does not
occur prior to execution, or after a jump instruction. Bit string instructions
will only increment PC after they have finished, but can be "saved" and paused
by system interrupts.<br /><br />

PC cannot be read by the program, though by definition it would change as soon
as it was read anyway. If the value in this register is required for whatever
reason, use the <i>JAL</i> instruction with a displacement value of 4 and then
use the contents of r31.<br /><br />

<a name="cpusystemregisters"><b>System Registers</b></a><br /><br />

There are 10 system registers, with the following names and symbols:

<pre>
  PSW    Program Status Word
  EIPC   Exception/Interrupt PC
  EIPSW  Exception/Interrup PSW
  FEPC   "Fatal" (Duplexed) Exception PC
  FEPSW  Duplexed Exception PSW
  ECR    Exception Cause Register
  ADTRE  ADdress Trap Register for Execution
  CHCW   CacHe Control Word
  TKCW   TasK Control Word
  PIR    Processor ID Register
</pre>

The values of the system registers can be read by the program using the
<i>STSR</i> instruction and, with exception, written using the <i>LDSR</i>
instruction.<br /><br />

<span class="br"></span>

<a name="cpupswprogramstatusword"><b>PSW - Program Status
Word</b></a><br /><br />

The Program Status Word (PSW) register contains various fields that indicate
the current state of operations as well as ancillary results of instructions
after they are executed.<br /><br />

The format of PSW is as follows:<br />
<pre>   31        20 19 16 15 14 13 12 11 10  9   8   7   6   5   4   3  2 1 0
  +------------+-----+--+--+--+--+-----+---+---+---+---+---+---+--+--+-+-+
  |    RFU     | Int |NP|EP|AE|ID| RFU |FRO|FIV|FZD|FOV|FUD|FPR|CY|OV|S|Z|
  +------------+-----+--+--+--+--+-----+---+---+---+---+---+---+--+--+-+-+
  Bits: 12        4    1  1  1  1   2    1   1   1   1   1   1   1  1 1 1
</pre>
<div class="indent">
<i>Z - Zero</i> - Set when the result of an operation is zero, cleared
otherwise.<br /><br />
<i>S - Sign</i> - A copy of the most significant bit of the result of an
operation. For signed operations, this indicates a negative number.<br /><br />
<i>OV - Overflow</i> - Set when an operation exceeds the range of a signed
integer and corrupts the sign bit, cleared otherwise. This can indicate, as an
example, a negative result when adding two positive numbers.<br /><br />
<i>CY - Carry</i> - Set when an operation exceeds the range of an unsigned
integer, cleared otherwise. This can occur, as an example, when subtracting a
value from a lesser value.<br /><br />
<i>FPR - Floating-Point Precision Degradation</i> - Set when the result of a
floating-point operation loses precision due to some information not being
contained within the significant digits. This flag is never cleared by
floating-point instructions.<br /><br />
<i>FUD - Floating-Point Underflow</i> - Set when the result of a floating-point
operation is a denormal number and not zero. This flag is never cleared by
floating-point instructions.<br /><br />
<i>FOV - Floating-Point Overflow</i> - Set when the result of a floating-point
operation is above the maximum normalized value that can be expressed by the
data type. This flag is never cleared by floating-point
instructions.<br /><br />
<i>FZD - Floating-Point Zero Division</i> - Set when attempting to divide by
zero in a floating-point operation if the numerator is not also zero. This flag
is never cleared by floating-point instructions.<br /><br />
<i>FIV - Floating-Point Invalid Operation</i> - Set when attempting to divide 
0 / 0 or convert a value to an integer that cannot be represented with 32 bits.
This flag is never cleared by floating-point instructions.<br /><br />
<i>FRO - Floating-Point Reserved Operand</i> - Set when one or both operands of
a floating-point operation is/are any of the following: a denormal number, NaN,
infinity or negative infinity. This flag is never cleared by floating-point
instructions.<br /><br />
<i>RFU - Reserved for Future Use</i><br /><br />
<i>ID - Interrupt Disable</i> - Set this when maskable interrupts should be
ignored.<br /><br />
<i>AE - Address Trap Enable</i> - Set this to enable the hardware breakpoint
debugging function.<br /><br />
<i>EP - Exception Pending</i> - Indicates if exception/interrupt handling is in
progress.<br /><br />
<i>NP - NMI Pending</i> - Indicates if non-maskable interrupt handling is in
progress.<br /><br />
<i>Int - Interrupt Mask Level</i> - Formally <i>I3-I0</i>, sets the minimum
interrupt level at which maskable interrupts are to be processed.<br /><br />
<i>RFU - Reserved for Future Use</i>
</div><br />
Manipulation of PSW can be done via the <i>LDSR</i>/<i>STSR</i> and
<i>CLI</i>/<i>SEI</i> instructions.<br /><br />

The conditions pertinent to the <i>Bcond</i> and <i>SETF</i> instructions
check for specific combinations of flags in PSW.<br /><br />

<span class="br"></span>

<a name="cpustatussavingregisters"><b>EIPC, EIPSW, FEPC and FEPSW -
Exception/Interrupt Status Saving Registers</b></a><br /><br />

When an exception or interrupt occurs, the contents of
<a href="#cpupcprogramcounter">PC</a> and
<a href="#cpupswprogramstatusword">PSW</a> are stored into these status saving
registers so that program flow can continue after the exception or interrupt
is handled.<br /><br />

Under normal circumstances, only EIPC and EIPSW are needed. If an exception is
already being processed when another exception occurs (which, under normal
circumstances, should only happen because of an interrupt), a <i>duplexed
exception</i> occurs and is processed like a non-maskable interrupt. In this
case, FEPC and FEPSW are used as well to allow returning to the handler of the
first exception.<br /><br />

If a non-maskable interrupt occurs on its own--outside of the context of a
duplexed exception--then only FEPC and FEPSW are used and they will return to
the program.<br /><br />

In either case, returning from and acknowledging exceptions/interrupts is done
with the <i>RETI</i> instruction. Since the corresponding *PSW register
contains the status of PSW prior to the occurrence of the exception/interrupt
in question, <i>RETI</i> will implicitly clear the pending flags.<br /><br />

<a name="cpuecrexceptioncauseregister"><b>ECR - Exception Cause
Register</a></b><br /><br />

During exception/interrupt processing, the source of the exception can be
resolved, as the name implies, by examining the Exception Cause Register
(ECR).<br /><br />

The format of ECR is as follows:<br />
<pre>   31            16 15             0
  +----------------+----------------+
  |      FECC      |      EICC      |
  +----------------+----------------+
</pre>
<div class="indent">
<i>EICC</i> - The exception code of the first exception that
occurs.<br /><br />
<i>FECC</i> - For duplexed exceptions, the exception code of the second
exception that occurred.
</div><br />

Exception codes are 16-bit, and the source of the exception is stored into
ECR.EICC. In the event of a duplexed exception, the code for the second
exception that occurred is transferred into ECR.FECC. Duplexed exceptions can
be detected by the NMI handler by checking whether the EP flag is set in <a
href="#cpupswprogramstatusword">PSW</a>. This can be accomplished via the
<i>STSR</i> instruction.<br /><br />

ECR cannot be written to by the program and therefore cannot be changed with
the <i>LDSR</i> instruction. However, it is not truly read-only, so the CPU is
still able to modify it.<br /><br />

<a name="cpuadtreaddresstrap"><b>ADTRE - Address Trap Register for
Execution</b></a><br /><br />

The Address Trap Register for Execution (ADTRE) is used to provide hardware
breakpoint functionality for debugging. If
<a href="#cpupswprogramstatusword">PSW</a>.AE is set, and the value of
<a href="#cpupcprogramcounter">PC</a> matches the value of ADTRE, then an
exception is triggered instead of executing the instruction at that
address.<br /><br />

<span class="br"></span>

<a name="cpuchcwcachecontrolword"><b>CHCW - Cache Control
Word</b></a><br /><br />

The Cache Control Word (CHCW) register is used by programs to configure the
state of the V810 family processors' internal instruction cache. The cache
contains 128 entries at 8 bytes each for a total of 1 KB cachable
memory, which is used to accelerate reads and writes between the CPU and system
memory.<br /><br />

<i>Editor's Note: The exact behavior of the cache--how it populates entries
and its replacement policy--is not specified in the V810 family documentation.
Since it has no bearing on emulation (except in the unlikely event the program
manipulates dumped cache data for whatever reason), cache functionality really
doesn't need to be implemented in an emulator.</i><br /><br />

Commands for cache control are issued when CHCW is written to by the
<i>LDSR</i> instruction. Only one of four commands may be issued to the cache
during a single <i>LDSR</i> operation. All cache operations complete before the
next instruction is fetched, and any interrupts that occur are held until the
cache operation completes. (In all cases, interrupts will be processed after
the execution of the instruction they coincide with, and before the next
instruction.)<br /><br />

CHCW has the following format:<br />
<pre>   31        20 19         8 7 6  5   4  3 2  1   0
  +------------,------------+---+---+---+---+---+---+
  |    CEN    (SA)   CEC    |RFU|ICR|ICD|RFU|ICE|ICC|
  +------------'------------+---+---+---+---+---+---+
  Bits: 12    (24)    12      2   1   1   2   1   1
</pre>
<div class="indent">
<i>ICC - Instruction Cache Clear</i> - Set this to 1 to clear cache entries.
When doing so, also set CEN to the index of the first entry to clear and CEC to
the number of entries to clear. Clearing cache entries will always stop after
the last entry, which has significance in situations where CEN + CEC > 128.
This value is always read (via the <i>STSR</i> instruction) as 0.<br /><br />
<i>ICE - Instruction Cache Enable</i> - Set this to 1 to enable the instruction
cache, and to 0 to disable it. This is the only value that can be read back as
1 via the <i>STSR</i> instruction.<br /><br />
<i>RFU - Reserved for Future Use</i> - Always read as 0.<br /><br />
<i>ICD - Instruction Cache Dump</i> - Set to 1 to perform a dump of the cache.
When doing so, also set SA to the upper 24 bits of the dump/restore area.
This value is always read as 0.<br /><br />
<i>ICR - Instruction Cache Restore</i> - Set to 1 to perform a restore of the
cache. When doing so, also set SA to the upper 24 bits of the dump/restore
area. This value is always read as 0.<br /><br />
<i>RFU - Reserved for Future Use</i> - Always read as 0.<br /><br />

SA, CEN and CEC share the same 24 bits of the CHCW register. Their use depends
on the context in which they are used.<br /><br />

<i>SA - Spill-Out Base Address</i> - The upper 24 bits of the memory location
to use as the cache dump/restore area during dump and restore operations. The
contents of the cache are written to this address during a dump and read during
a restore. This value is always read as 0.<br /><br />
<i>CEC - Clear Entry Count</i> - The number of cache entries to clear during a
clear operation. If CEC > 128, then 128 will be used as the count. In the event
CEN + CEC > 128, then 128 - CEN entries are cleared instead. This value is
always read as 0.<br /><br />
<i>CEN - Cache Entry Number</i> - The index of the starting cache entry to
clear (0-127) during a clear operation. If CEN >= 128, nothing happens. This
value is always read as 0.
</div><br />

No more than one of ICC, ICE, ICD and ICR should be set in a single write via
the <a href="#cpucpucontrol"><i>LDSR</i></a> instruction. If more than one is
set, operation is not guaranteed. <i>Editor's Note: But what exactly would
happen?</i><br /><br />

After the cache is dumped, all entries must be cleared before the cache is
enabled again. <i>Editor's Note: And what if they aren't?</i><br /><br />

<span class="br"></span>

<a name="cputkcwtaskcontrolword"><b>TKCW - Task Control
Word</b></a><br /><br />

The Task Control Word (TKCW) register is fixed and read-only on the V810
family, and therefore is of little interest to the programmer. It is documented
here for the sake of completeness.<br /><br />

As it pertains to the <i>STSR</i> instruction, TKCW has a value of
0x000000E0.<br /><br />

TKCW controls the specifics of floating-point operations. It has the following
format:<br />
<pre>   31                    9  8   7   6   5   4   3   2  1 0
  +-----------------------+---+---+---+---+---+---+---+---+
  |          RFU          |OTM|FIT|FZT|FVT|FUT|FPT|RDI|RD |
  +-----------------------+---+---+---+---+---+---+---+---+
  Bits:      23             1   1   1   1   1   1   1   2
</pre>
<div class="indent">
<i>RD - Rounding Control</i> - Specifies the direction of rounding. This is 
fixed to 00: toward nearest.<br /><br />
<i>RDI</i> - Rounding Control Bit for Integer Conversion</i> - Specifies how to
round when converting to integer. This is fixed to 0: use the same direction as
RD. This causes the <i>CVT.SW</i> instruction to operate differently than the
<i>TRNC.SW</i> instruction.</i><br /><br />
<i>FPT - Precision Trap Enable</i> - Specifies if FPR (floating-point precision
degradation) exceptions can occur. This is fixed to 0: precision degradation
exceptions cannot occur.<br /><br />
<i>FUT - Underflow Trap Enable</i> - Specifies if FUD (floating-point
underflow) exceptions can occur. This is fixed to 0: underflow exceptions
cannot occur.<br /><br />
<i>FVT - Overflow Trap Enable</i> - Specifies if FOV (floating-point
overflow) exceptions can occur. This is fixed to 1: overflow exceptions can
occur.<br /><br />
<i>FZT - Zero Divide Trap Enable</i> - Specifies if FZD (floating-point zero
divide) exceptions can occur. This is fixed to 1: zero divide exceptions can
occur.<br /><br />
<i>FIT - Invalid Operation Trap Enable</i> - Specifies if FIV (floating-point
invalid operatin) exceptions can occur. This is fixed to 1: invalid
operation exceptions can occur.<br /><br />
<i>OTM - Operand Trap Mask</i> - Specifies if FRO (floating-point reserved
operand) exceptions are masked. This is fixed to 0: reserved operand exceptions
can occur (are not masked).<br /><br />
<i>RFU - Reserved for Future Use</i>
</div><br />

<a name="cpupirprocessoridregister"><b>PIR - Processor ID
Register</a></b><br /><br />

The Processor ID Register (PIR) contains a unique code identifying which
processor is present so that software can decide how to operate. It has a fixed
value and is read-only.<br /><br />

As it pertains to the <i>STSR</i> instruction, PIR has a value of
0x00005346 on Virtual Boy.</i><br /><br />

The Virtual Boy NVC is a non-standard V810 processor. For the sake of
completeness, PIR has the following format on ordinary V810 family
processors:<br />
<pre>   31            16 15          4 3   0
  +----------------+-------------+-----+
  |      RFU       |     PT      |NECRV|
  +----------------+-------------+-----+
  Bits:   16             12         4
</pre>
<div class="indent">
<i>NECRV - NEC Reserved</i> - Treat this as undefined.<br /><br />
<i>PT - Processor Type</i> - Set to 0x810 for the V810 family.<br /><br />
<i>RFU - Reserved for Future Use</i> - Fixed to zero.
</div><br />



<h1><a name="cpudatatypesandconventions">CPU Data Types and
Conventions</a></h1>

The V810 family of processors can work with a small number of different data
types, which are referred to by specific names. In general, the CPU can work
with integers, floating-point numbers and strings of bits.<br /><br />

<a name="cpubyteorder"><b>Byte Order</b></a><br /><br />

For all data types on V810 family CPUs, bytes are stored and read with the low
(least significant) byte first. In other words, the system byte order is
little-endian.<br /><br />

<a name="cpuintegerdatatypes"><b>Integer Data Types</b></a><br /><br />

Integer data types can be read and stored in units of 8, 16 or 32 bits, but
processing only occurs with 32-bit integers. The different data sizes are
referred to by the following names on the V810 family:<br /><br />

<div class="indent">
&bull; 8-bit - Byte<br />
&bull; 16-bit - Halfword<br />
&bull; 32-bit - Word<br />
</div><br />

When accessing memory or port addresses for transferring data of a given type,
the address itself must fall on a multiple of the size of that data type. For
example, when loading a word from RAM, the address in memory must be divisible
by 4--it must fall on a word boundary.<br /><br />

Values read as immediate parameters in instructions may be sign extended when
converting to 32 bits, but also may not. Sign extension means that the extra
bits prepended to the value match the most significant bit of the value itself.
Contrast with zero extension, which always uses 0 for the extra bits.
Typically, arithmetic and address displacement values are sign-extended, while
bitwise values are zero-extended. Refer to the documentation for individual
instructions to determine what form of extension is to be used.<br /><br />

Integers can be processed as both signed and unsigned, depending on the
instruction used an/or the condition to check for. The nature of two's
complement storage means the same mathematical procedures can be performed for
both.<br /><br />

<span class="br"></span>

<a name="cpufloatingpointdatatype"><b>Floating-Point Data
Type</b></a><br /><br />

The floating-point format used by the V810 family is IEEE-754 32-bit Single,
referred to as "floating short" in the documentation. The data type has the
following format:<br /><br />

<div class="indent">
<pre>
31 30    23 22                    0
+-+--------+-----------------------+
|S|  Exp.  |      Significand      |
+-+--------+-----------------------+
</pre>
<i>Significand</i> - Represents the portion of a binary fractional value after
the point (halves, quarters, eighths, etc.). For normalized values, there is an
implicit 1 on the integer side of the point, whereas for denormal values there
is an implicit 0. The word "mantissa" is a common name for this value, but
IEEE stresses "significand" to avoid ambiguity with the use of mantissa in
regards to logarithms, which is not the same type of value.<br />
<i>Exp. - Exponent</i> - An exponent to raise 2 to the power of when
constructing the number represented by the data. The value packed into these 8
bits is biased: subtract 127 from their value to resolve the true
exponent.<br />
<i>S - Sign</i> - The sign bit. If clear, the number is positive. If set, the
number is negative.<br />
</div><br />

The <I>Exponent</i> and <i>Significand</i> fields are examined to determine
what kind of number is being represented:<br /><br />

<div class="indent">
&bull; Infinity - <i>Exponent</i> is all 1s and <i>Significand</i> is all
0s.<br />
&bull; NaN (not a number) - <i>Exponent</i> is all 1s and <i>Significand</i> is
not all 0s.<br />
&bull; Normalized number - <i>Exponent</i> is a mixture of 1s and 0s. The
significand has a leading 1 before the point.<br />
&bull; Denormalized number - <i>Exponent</i> is all 0s. The significand has a
leading 0 before the point.<br />
&bull;Zero - <i>Exponent</i> is all 0s and <i>Significand</i> is all 0s.
Technically a denormal number.<br />
</div><br />

All types of numbers are signed, meaning there can be such things as negative
zero and negative infinity.<br /><br />

Construction of the represented number is done with the following
formulas:<br /><br />

<div class="indent">
&bull; Normalized = (-1 ^ <i>Sign</i>) * (2 ^ (<i>Exponent</i> - 127)) *
1.<i>Significand</i><br />
&bull; Denormalized = (-1 ^ <i>Sign</i>) * 0.<i>Significand</i><br />
&bull; Infinity and NaN = Cannot be calculated.<br />
</div><br />

On the V810 family, only normalized numbers and the special-case denormal value
zero are accepted as valid operands in the
<a href="#cpufloatingpointinstructions">Floating-Point instructions</a>. If an
indefinite, non-number or non-zero denormal number is used (called "reserved
operands"), it will raise an exception.<br /><br />

The following cases are detected during processing:<br /><br />

<div class="indent">
&bull; Use of a reserved operand is prohibited.<br />
&bull; An attempt to divide zero by zero results in an invalid operation.<br />
&bull; An attempt to divide a non-zero number by zero results in a zero
division error.<br />
&bull; If the exponent of the result of a floating-point operation is greater
than 127, an overflow occurs.<br />
&bull; If the exponent of the result of a floating-point operation is less than
-126 (a denormal number) and not zero, an underflow occurs.<br />
&bull; If the significand of the result of a floating-point operation has
significance beyond 23 bits, precision degradation occurs.<br />
</div><br />

<a name="cpubitstring"><b>Bit String</b></a><br/ ><br />

In addition to the data types that can be processed by register operations, the
V810 family also supports strings of data of arbitrary length--precise on the
bit level--called bit strings. The bit string operations provide a convenience
for, and hardware acceleration of, bulk processing of data in system
memory.<br /><br />

Bit strings are defined by three properties:<br /><br />

<div class="indent">
&bull; Starting Word Address - The address in memory of the word that contains
the first bit of the string. Must fall on a word boundary.<br />
&bull; Starting Bit Offset - The index (0-31) of the first bit of the string
within the starting word, relative to the lowest bit.<br />
&bull; Length - The size of the string, in bits. This is a 32-bit unsigned
value, meaning strings can be as large as (2<sup>32</sup> - 1) bits, or 512 MB
minus one bit.<br />
</div><br />

Bit string operations work on two bit strings--a source and a destination--both
of the same length. For more information on bit strings, refer to the
<a href="#cpubitstringinstructions">CPU Bit String Instructions</a>
section.<br /><br />

<span class="br"></span>

<a name="cpuassemblyconventions"><b>Assembly Conventions</b></a><br /><br />

The official notation of assembly instructions on the V810 family is as
follows:<br /><br />

<div class="indent">
&bull; Mnemonics (instruction names) are all-uppercase.<br />
&bull; Registers are specified with the lowercase letter <i>r</i> followed by
the number of the register, expressed in decimal.<br />
&bull; Source operands are listed on the left, and destination operands on the
right.* Immediate values are always listed first.<br />
&bull; Load/store instructions list the displacement value immediately followed
by the register name in [] brackets.<br />
&bull; The <a href="#cpuconditionalbranches"><i>Bcond</i> instruction</a> is
never used by name, but rather the conditions themselves are used as the
mnemonic following the capital letter <i>B</i>.<br />
&bull; The <a href="#cpucpucontrol"><i>LDSR</i>/<i>STSR</i> instructions</a>
specify the <a href="#cpusystemregisters">system register</a> by name rather
than by numeric ID.<br />
&bull; The <a href="#cpumiscinstructions"><i>SETF</i> instruction</a> specifies
the condition by name rather than by numeric ID.<br />
&bull; The destination register of the <a href="#cpunormaljumps"><i>JMP</i>
instruction</a> has [] brackets around it.<br />
</div><br />

* - Some instructions will have reversed operand order compared to other
instructions of the same format. For example, this applies to
<a href="#cpustoreandoutputregister">store instructions</a> and
<i>LDSR</i> among others.<br /><br />

Example instructions:<br />

<pre class="indent">
HALT
JMP   [r12]
ANDI  7FFFh, r1, r2
LD.W  4[r1], r3
BNE   -12
LDSR  r4, PSW
SETF  NE
</pre>

A few considerations:<br /><br />

<div class="indent">
&bull; Numeric representaiton for immediate and displacement values is
determined by the assembler/disassembler. Typical representations include
signed decimal, or unsigned hexadecimal followed by the lowercase letter
<i>h</i> (as in 7FFFh).<br />
&bull; Comment specification is determined by the assembler, but is typically
indicated by the <i>;</i> semicolon. C/C++ style comments <i>/* */</i> and
<i>//</i> may also be used in some cases.<br />
&bull; Existing program code may use all-lowercase mnemonics for instructions,
different numeric representations, different notation of registers and/or other
differences from the V810 family documentation.<br />
</div><br />

<span class="br"></span>

<a name="cpucallingconvention"><b>Calling Convention</b></a><br /><br />

Programs written for Virtual Boy using the Nintendo-supplied C compiler follow
a particular calling convention for functions and stack
manipulation.<br /><br />

The <a href="#cpuprogramregisters">program registers</a> have the following
significance in the Virtual Boy calling convention:<br /><br />

<div class="indent">
&bull; r0 - Fixed value of 0.<br />
&bull; r1 - Not used by the compiler, but is used in hand-coded and template
assembly for construction of 32-bit immediate values and for calculating
effective addresses.<br />
&bull; r2 - Not used by the compiler. The V810 family specifies this register
as the stack pointer for exception handlers. Exceptions on Virtual Boy use r3
instead.<br />
&bull; r3 - The stack pointer. Commercial games initialize this to
0x0500FFFC.<br />
&bull; r4 - Data pointer. Global and static variables are referenced relative
to the address in this register. Commercial games initialize this to
0x05008000.<br />
&bull; r5 - Not used by the compiler. The V810 family specifies this register
as the text pointer, but text data on Virtual Boy is always at
0x07000000.<br />
&bull; r6-r9 - Reserved for function arguments. r6 receives the first argument
and r9 receives the fourth argument.<br />
&bull; r10-r19 - Local function data. None of these registers are guaranteed to
be preserved after a function returns.<br />
&bull; r20-r29 - Not used by the compiler.<br />
&bull; r30 - Reserved for CPU operation. In particular,
<a href="#cpuarithmeticoperations">integer multiply and divide instructions</a>
modify this register.<br />
&bull; r31 - Link pointer. This must be set to the return address upon entering
a function body. This register is set automatially by the
<a href="#cpunormaljumps"><i>JAL</i> instruction</a>.<br />
</div><br />

When pushing data to the stack, first decrease the value in r3, then write the
data to the new address.<br /><br />

When calling a function, 16 bytes are always allocated on the stack. These
bytes are defined for use with the <code>stdarg</code> and
<code>varargs</code> calling conventions to add the first four function
arguments to the stack. Even when the standard calling convention is used,
these bytes are always present for all function calls.<br /><br />

The first four arguments in function calls are passed in registers r6 through
r9, respectively. Additional arguments are pushed to the stack (appearing after
the aforementioned 16 bytes), where arguments of lower order are stored to
lower addresses. Upon entering a function body, the address of the fifth
argument is 10h[r3], the address of the sixth argument is 14h[r3], and
so-on.<br /><br />

The return value from a function, if any, is stored in r10.<br /><br />

r31 is populated with the return address when returning from a function. The
compiler always uses the instruction "<code><a href="#cpunormaljumps">JMP</a>
[r31]</code>" to return from functions.<br /><br />



<h1><a name="cpuexceptionsandinterrupts">CPU Exceptions &amp;
Interrupts</a></h1>

An <i>exception</i> on the V810 family processors is an event that triggers
special CPU behavior. In particular, the current
<a href="#cpupcprogramcounter">PC</a> and
<a href="#cpupswprogramstatusword">PSW</a> are saved in the
<a href="#cpustatussavingregisters">status saving registers</a>, and execution
is redirected to a predefined address, called an <i>exception
handler</i>.<br /><br />

An <i>interrupt</i> is an event raised by hardware activity, such as by the
<a href="#virtualimageprocessorvip">VIP</a> or <a href="#hardwaregamepad">game
pad</a>. Interrupts are a subset of exceptions.<br /><br />

<a name="cpuexceptionsexceptionhandlers"><b>Exception
Handlers</b></a><br /><br />

All exceptions have an <i>exception code</i>, which represents the type of
exception that was raised. Exception codes are 16 bits and match the low 16
bits of the addresses of the corresponding exception handlers. During the
initial exception processing, the exception code is copied into the
<a href="#cpuecrexceptioncauseregister">ECR</a> register.<br /><br />

Every exception code has a corresponding address that gets stored to <i>PC</i>
when the exception occurs. These handlers are located at the very end of the
CPU's address space, in the 0xFFFFFE00 - 0xFFFFFFFF range. Bytes within this
region represent the actual instructions for the CPU to execute.<br /><br />

All handlers begin on a 16-byte boundary (the lowest 4 bits are zeroes),
meaning each type of exception has only 16 bytes available for handler code; a
maximum of 8 instructions. However, this is enough space to initialize and
execute a <a href="#cpunormaljumps"><i>JMP</i></a> instruction.<br /><br />

For a full list of handler addresses on Virtual Boy, refer to
<a href="#cpulistofexceptions">CPU List of Exceptions</a>.<br /><br />

<a name="cpuexceptionsrestorepc"><b>Restore PC</b></a><br /><br />

The return address for an exception is stored into the appropriate status
saving register, though exactly what that is in relation to <i>PC</i> depends
on the type of exception that was triggered.<br /><br />

The address <i>Current PC</i> is the address of the instruction that raised the
exception, if the exception is the result of an invalid operation of some sort.
These same instructions can be aborted by interrupts, in which case Current PC
is still used.<br /><br />

The address <i>Next PC</i> is the address of the instruction following the
instruction currently being executed. Normally, Next PC is used for interrupts,
but if an instruction is aborted by the interrupt, Current PC is used instead.
Except for instructions that can be aborted by an interrupt, all instructions
will complete execution before the interrupt is processed.<br /><br />

The <a href="#cpucpucontrol"><i>TRAP</i></a> instruction's behavior is not
invalid--its purpose is to raise an exception--so it consequently uses Next PC
as the Restore PC.<br /><br />

The following instructions can be aborted by interrupts and/or raise
exceptions: <a href="#cpuarithmeticoperations"><i>DIV</i>/<i>DIVU</i></a>,
<a href="#cpufloatingpointinstructions">floating-point instructions</a> and
<a href="#cpubitstringinstructions">bit string instructions</a>.<br /><br />

Additionally, any illegal opcode (an opcode without a corresponding
instruction), including sub-opcodes of bit string and floating-point
instructions, will raise an exception.<br /><br />

<a name="cpuexceptionsmaskinginterrupts"><b>Masking
Interrupts</b></a><br /><br />

If an interrupt is masked, it will not be processed. Masking can occur in two
ways: by disabling interrupts via the <i>ID</i> flag of the <i>PSW</i>
register, or if the interrupt's interrupt level is less than the minimum
<i>Interrupt Mask Level</i> specified in <i>PSW</i>.<br /><br />

Interrupts can be disabled entirely by setting the <i>ID</i> flag in the
<i>PSW</i> register. This can be done with the
<a href="#cpucpucontrol"><i>LDSR</i></a> and
<a href="#cpunintendoinstructions"><i>SEI</i></a> instructions. While the
<i>ID</i> flag is set, all maskable interrupts are ignored regardless of their
interrupt level. To enable interrupts, clear the flag with <i>LDSR</i> or
<a href="#cpunintendoinstructions"><i>CLI</i></a>.<br /><br />

While interrupts are enabled, they can still be ignored if their interrupt
level is less than the minimum <i>Interrupt Mask Level</i> specified in the
<i>PSW</i> register. The interrupt level of any given interrupt is
hardware-defined, so system designers should assign lower interrupt levels to
less important interrupts.<br /><br />

Interrupts are always ignored if the <i>NP</i> or <i>EP</i> flags of the
<i>PSW</i> register are set, meaning an interrupt cannot be processed while
another interrupt is already being processed.<br /><br />

The Reset and non-maskable interrupts (NMI) cannot be disabled and will always
be processed. The NMI is not used on the Virtual Boy.<br /><br />

<span class="br"></span>

<a name="cpuexceptionsduplexedexceptions"><b>Duplexed
Exceptions</b></a><br /><br />

A duplexed exception occurs if an exception occurs while another exception is
already being processed. Both exception codes are stored in the <i>ECR</i>
register and the duplexed exception is processed like an NMI.

For more information on what happens when a duplexed exception occurs, refer to
<a href="#cpuexceptionsexceptionprocessing">Exception
Processing</a>.<br /><br />

The NMI handler code can detect a duplexed exception by checking the <i>EP</i>
flag of the <i>PSW</i> register.<br /><br />

<a name="cpuexceptionsfatalexceptions"><b>Fatal Exceptions</b></a><br /><br />

If an exception occurs while an NMI (either by the hardware or as a duplexed
exception) is being processed, a machine fault/fatal exception
occurs.<br /><br />

For more information on what happens when a fatal exception occurs, refer to
<a href="#cpuexceptionsexceptionprocessing">Exception
Processing</a>.<br /><br />

Note that maskable interrupts cannot cause a fatal exception because they are
ignored when the <i>NP</i> or <i>EP</i> flag is set in the <i>PSW</i> register.
Since the Virtual Boy does not use the NMI, the only possible way for a
machine fault to occur is if the NMI handler itself raises an
exception.<br /><br />

<a name="cpuexceptionsexceptionpriority"><b>Exception
Priority</b></a><br /><br />

If multiple exceptions/interrupts occur simultaneously, the order in which they
are processed depends on their <i>priority</i>.<br /><br />

Exception priority is as follows, ordered highest to lowest:<br /><br />

<div class="indent">
&bull; Reset*<br />
&bull; NMI / Duplexed Exception<br />
&bull; <a href="#vipinterrupts">VIP interrupt</a>**<br />
&bull; <a href="#hardwarelinkport">Link interrupt</a>**<br />
&bull; <a href="#cpumemorymap">Cartridge interrupt</a>**<br />
&bull; <a href="#hardwaretimer">Timer Zero interrupt</a>**<br />
&bull; <a href="#hardwaregamepad">Game Pad interrupt</a>**<br />
&bull; Address Trap<br />
&bull; <a href="#cpucpucontrol"><i>TRAP</i></a> instruction<br />
&bull; Illegal Opcode<br />
&bull;  Zero Division
(<a href="#cpuarithmeticoperations"><i>DIV/DIVU</i></a> instructions)<br />
&bull; <a href="#cpufloatingpointinstructions">Floating-Point</a> Reserved
Operand***<br />
&bull; Floating-Point Invalid Operation***<br />
&bull; Floating-Point Zero Division***<br />
&bull; Floating-Point Overflow***<br />
</div><br />

* - Reset does not behave like other interrupts, since it forcefully
initializes the hardware. For more information on what happens during Reset,
refer to the <a href="#systemreset">System Reset</a> section.<br /><br />

** - Note that only the interrupt with the highest priority of simultaneous
interrupts will be processed because interrupts are explicitly ignored during
exception processing.<br /><br />

*** - Only one floating-point exception can occur for a single instruction. If
a given instruction qualifies for more than one (such as dividing NaN by zero), only
the one with the highest priority will be caught and processed. This includes
the setting of the corresponding status flag in
<a href="#cpupswprogramstatusword">PSW</a>.<br /><br />

Floating-point underflow and precision degredation have defined exception
codes and handler addresses, but cannot actually occur on V810 because of the
configuration of <a href="#cputkcwtaskcontrolword">TKCW</a>.<br /><br />

<span class="br"></span>

<a name="cpuexceptionsexceptionprocessing"><b>Exception
Processing</b></a><br /><br />

When a maskable interrupt occurs:<br /><br />
<div class="indent">
if ( (<a href="#cpupswprogramstatusword">NP</a> or <a
href="#cpupswprogramstatusword">EP</a> or
<a href="#cpupswprogramstatusword">ID</a>) = 1 ) or (interrupt_level &lt; <a
href="#cpupswprogramstatusword">Int</a>) then -- Interrupt is masked<br />
    <div class="indent">
    ignore interrupt
    </div>
else -- Interrupt is accepted<br />
    <div class="indent">
    <a href="#cpustatussavingregisters">EIPC</a> = PC<br />
    <a href="#cpustatussavingregisters">EIPSW</a> = PSW<br /><br />
    if interrupt_level &lt; 15 then<br />
        <div class="indent">
        Int = interrupt_level + 1
        </div>
    else <br />
        <div class="indent">
        Int = 15
        </div>
    end if<br /><br />

    accept interrupt
    </div>
end if
</div><br />

When an exception or accepted interrupt occurs:<br /><br />
<div class="indent">
if <a href="#cpupswprogramstatusword">NP</a> = 1 then -- <a
href="#cpuexceptionsfatalexceptions">Fatal exception</a><br />
    <div class="indent">
    word ptr [0x00000000] = 0xFFFF0000 or exception_code<br />
    word ptr [0x00000004] = <a href="#cpupcprogramcounter">PC</a><br />
    word ptr [0x00000008] = <a href="#cpupswprogramstatusword">PSW</a><br />
    halt until <a href="#systemreset">Reset</a>
    </div>
else if <a href="#cpupswprogramstatusword">EP</a> = 1 then -- <a
href="#cpuexceptionsduplexedexceptions">Duplexed exception</a><br />
    <div class="indent">
    <a href="#cpustatussavingregisters">FEPC</a> = PC<br />
    <a href="#cpustatussavingregisters">FEPSW</a> = PSW<br />
    <a href="#cpuecrexceptioncauseregister">ECR</a>.FECC = exception_code<br />
    NP = 1<br />
    <a href="#cpupswprogramstatusword">ID</a> = 1<br />
    <a href="#cpupswprogramstatusword">AE</a> = 0<br />
    PC = 0xFFFFFFD0
    </div>
else -- Normal exception/interrupt<br />
    <div class="indent">
    <a href="#cpustatussavingregisters">EIPC</a> = PC -- Already handled for interrupts<br />
    <a href="#cpustatussavingregisters">EIPSW</a> = PSW -- Already handled for interrupts<br />
    ECR.EICC = exception_code<br />
    EP = 1<br />
    ID = 1<br />
    AE = 0<br />
    PC = handler_address
    </div>
end if
</div><br />

<a name="cpuexceptionsreturningfromexceptions"><b>Returning from
Exceptions</a></b><br /><br />

When handling has been completed for an exception, interrupt or trap, control
is returned to the program by the <a href="#cpucpucontrol"><i>RETI</i></a>
instruction. The exact behavior of <i>RETI</i> depends on the status of the
<i>NP</i> flag in the <a href="#cpupswprogramstatusword"><i>PSW</i></a>
register:<br /><br />

<div class="indent">
<i>NP = 1</i> - If an NMI or
<a href="#cpuexceptionsduplexedexceptions">duplexed exception</a> is being
processed, the <a href="#cpupcprogramcounter">PC</a> and PSW registers are
loaded from the <a href="#cpustatussavingregisters">FEPC</a> and
<a href="#cpustatussavingregisters">FEPSW</a> registers,
respectively.<br /><br />

<i>NP = 0</i> - If an NMI or duplexed exception is <i>not</i> being processed,
the PC and PSW registers are loaded from the
<a href="#cpustatussavingregisters">EIPC</a> and
<a href="#cpustatussavingregisters">EIPSW</a> registers, respectively. Note
that this is true even if the <i>EP</i> flag is cleared.
</div><br />

<span class="br"></span>

<a name="cpuexceptionsaddresstrap"><b>Address Trap</b></a><br /><br />

An address trap is a special debugging exception in the V810 family processors.
It can be used to configure a hardware breakpoint on a particular address,
which can then cause an exception on execution at that address.<br /><br />

If the <i>AE</i> flag in <a href="#cpupswprogramstatusword"><i>PSW</i></a> is
set and PC becomes equal to
<a href="#cpuadtreaddresstrap">ADTRE</a> when it prepares to execute an
instruction, an address trap occurs and the corresponding exception is
processed.<br /><br />

Address traps have an exception code of 0xFFC0 and branch CPU execution to
address 0xFFFFFFC0.<br /><br />



<h1><a name="cpucachedumpandrestore">&nbsp;CPU Cache Dump &amp;
Restore</a></h1>

The V810 family processors provide up to 1 KB of CPU instruction cache, the 
contents of which can be dumped to and restored from system memory. For
information on how to use the cache functions, refer to <a
href="#cpuchcwcachecontrolword">CHCW - Cache Control Word</a>. This section
documents the format of the data in the dump/restore area.<br /><br />

Cache dump and restore functions specify the upper 24 bits of the address to
dump to/restore from. The data itself occupies 1536 bytes, which doesn't
technically require a full 12 bits of addressing. Two kinds of data are written
to the dump/restore area:<br /><br />
<div class="indent">
<i>Block</i> - The 8 bytes representing the cache data for one cache entry.
These are stored in the same order they appear within CPU memory.<br /><br />
<i>Entry</i> - A bit-packed word representing one cache entry. This element has
the following format:<br />
<pre>  31 28 27 23 22 21                  0
  +----+-----+-+----------------------+
  | 0  |NECRV|V|         TAG          |
  +----+-----+-+----------------------+
</pre>
<div class="indent">
<i>TAG</i> - Bits 31-10 of the cache entry tag, which represent the high 22
bits of the address that the cache entry represents.<br /><br />
<i>V - Valid Bit</i> - Indicates if this entry is currently valid (not
cleared)<br /><br />
<i>NECRV - NEC Reserved</i> - Consider this undefined.
</div>
</div><br />

At the location specified by the <i>SA</i> field in <i>CHCW</i>:<br />
<pre>  SA + 0x00000000   128 Block elements, starting with cache entry 0
  SA + 0x00000400   128 Entry elements, starting with cache entry 0
  SA + 0x00000600   (This is the first byte after the dump data)
</pre>

Note that the cache tags are only precise to a 1 KB boundary.<br /><br />



<h1><a name="cpulistofexceptions">CPU List of Exceptions</a></h1>

The following chart lists the exceptions that can occur on Virtual
Boy:<br /><br />

<table>
<tr>
<td class="exhdr" style="width: 250px;">Name</td>
<td class="exhdr">Exception Code</td>
<td class="exhdr"><a href="#cpuexceptionsexceptionhandlers">Handler
Address</a></td>
<td class="exhdr"><a href="#cpuexceptionsrestorepc">Restore PC</a></td>
</tr>
<tr>
<td><a href="#hardwaregamepad">Game Pad</a></td>
<td class="exdef">0xFE00</td>
<td class="exdef">0xFFFFFE00</td>
<td class="exdef">Next PC*</td>
</tr>
<tr>
<td><a href="#hardwaretimer">Timer Zero</a></td>
<td class="exdef">0xFE10</td>
<td class="exdef">0xFFFFFE10</td>
<td class="exdef">Next PC*</td>
</tr>
<tr>
<td><a href="#cpumemorymap">Cartridge</a></td>
<td class="exdef">0xFE20</td>
<td class="exdef">0xFFFFFE20</td>
<td class="exdef">Next PC*</td>
</tr>
<tr>
<td><a href="#hardwarelinkport">Link</a></td>
<td class="exdef">0xFE30</td>
<td class="exdef">0xFFFFFE30</td>
<td class="exdef">Next PC*</td>
</tr>
<tr>
<td><a href="#vipinterrupts">VIP</a></td>
<td class="exdef">0xFE40</td>
<td class="exdef">0xFFFFFE40</td>
<td class="exdef">Next PC*</td>
</tr>
<tr>
<td><a href="#cpufloatingpointinstructions">Floating-Point</a> Reserved
Operand</td>
<td class="exdef">0xFF60</td>
<td class="exdef">0xFFFFFF60</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td>Floating-Point Overflow</td>
<td class="exdef">0xFF64</td>
<td class="exdef">0xFFFFFF60</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td>Floating-Point Zero Division</td>
<td class="exdef">0xFF68</td>
<td class="exdef">0xFFFFFF60</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td>Floating-Point Invalid Operation</td>
<td class="exdef">0xFF70</td>
<td class="exdef">0xFFFFFF60</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td><a href="#cpuarithmeticoperations">Zero Division</a></td>
<td class="exdef">0xFF80</td>
<td class="exdef">0xFFFFFF80</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td>Illegal Opcode</td>
<td class="exdef">0xFF90</td>
<td class="exdef">0xFFFFFF90</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td><a href="#cpucpucontrol"><i>TRAP</i></a> (<i>vector</i> &lt; 16)</td>
<td class="exdef">0xFFA0 + <i>vector</i></td>
<td class="exdef">0xFFFFFFA0</td>
<td class="exdef">Next PC</td>
</tr>
<tr>
<td><i>TRAP</i> (<i>vector</i> >=
16)</td>
<td class="exdef">0xFFA0 + <i>vector</i></td>
<td class="exdef">0xFFFFFFB0</td>
<td class="exdef">Next PC</td>
</tr>
<tr>
<td><a href="#cpuexceptionsaddresstrap">Address Trap</a></td>
<td class="exdef">0xFFC0</td>
<td class="exdef">0xFFFFFFC0</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td><a href="#cpuexceptionsduplexedexceptions">Duplexed
Exception</a></td>
<td class="exdef">0xFFD0</td>
<td class="exdef">0xFFFFFFD0</td>
<td class="exdef">Current PC</td>
</tr>
<tr>
<td><a href="#systemreset">Reset</a></td>
<td class="exdef">0xFFF0</td>
<td class="exdef">0xFFFFFFF0</td>
<td class="exdef">--</td>
</tr>
</table><br />

* - These interrupts will use Current PC if they cause an instruction to
abort. For more information, refer to <a href="#cpuexceptionsrestorepc">Restore
PC</a>.<br /><br />

Game Pad, Timer Zero, Cartridge, Link and VIP are all maskable interrupts.
Their interrupt levels are equal to the second-least-significant nibble of
their exception codes. For example, VIP has an exception code of 0xFE40, so its
interrupt level is 4.<br /><br />

All floating-point exceptions, including Invalid Operation, have the same
handler address: 0xFFFFFF60.<br /><br />

The NMI is not used on the Virtual Boy, but if it was, it would have the same
exception code and handler address as Duplexed Exception, and have the same
Restore PC policy as the other interrupts.<br /><br />



<h1><a name="cpuinstructionformats">CPU Instruction Formats</a></h1>
Instructions on the V810 family processors can be 16- or 32-bit, depending on
the opcode. Instructions are packed into bits using seven different formats,
depending on the type of instruction and which addressing mode it uses. NEC
refers to these formats simply as Format I through Format VII, and they are
defined below.<br /><br />

Instructions are read in 16-bit halfwords, where the low byte of each halfword
comes first. The opcode begins at the highest bit of the second byte, meaning
bit 15 and downward within the first halfword. For 32-bit instructions, a
second halfword is read, and the first halfword is treated as the upper 16 bits
of a 32-bit data unit.<br /><br />

<a name="cpuformati"><b>Format I</b> - Register-to-register</a><br />
<div class="indent">
Instruction size: 16 bits<br />
Field layout:<br />
<pre>   15  10 9   5 4   0
  +------+-----+-----+
  |  op  |reg2 |reg1 |
  +------+-----+-----+</pre>
<div class="arg">op</div> - The instruction's opcode.<br />
<div class="arg">reg2</div> - The 5-bit index (0-31) of the <i>destination</i>
register.<br />
<div class="arg">reg1</div> - The 5-bit index (0-31) of the <i>source</i>
register.<br /><br />
Example assembly notation: MOV r1, r2
</div><br />

<a name="cpuformatii"><b>Format II</b> - Immediate-to-register</a><br />
<div class="indent">
Instruction size: 16 bits<br />
Field layout:<br />
<pre>   15  10 9   5 4   0
  +------+-----+-----+
  |  op  |reg2 |imm5 |
  +------+-----+-----+</pre>
<div class="arg">op</div> - The instruction's opcode.<br />
<div class="arg">reg2</div> - The 5-bit index (0-31) of the destination
register.<br />
<div class="arg">imm5</div> - The 5-bit value used as the instruction's source
operand.*<br /><br />
* - Depending on the instruction, the immediate value may be sign- or
zero-extended, or used as a 5-bit value. For bit string instructions, this
field is used as a sub-opcode field.<br /><br />
Example assembly notation: ADD 5, r2
</div><br />

<a name="cpuformatiii"><b>Format III</b> - Conditional branch</a><br />
<div class="indent">
Instruction size: 16 bits<br />
Field layout:<br />
<pre> 15 13 12 9 8        0
  +---+----+----------+
  |op |cond|  disp9   |
  +---+----+----------+</pre>
<div class="arg">op</div> - The instruction's opcode.*<br />
<div class="arg">cond</div> - The 4-bit condition identifier specifying which
branch instruction this is.**<br />
<div class="arg">disp9</div> - A 9-bit, sign-extended displacement value
specifying the relative target address if the branch is taken.
<br /><br />
* - All of the conditional branch instructions have 100 as their opcode bits,
and no other instruction begins with those three bits.<br />
** - For a list of condition identifiers, refer to the <a
href="#cpujumpandcontrolinstructions">CPU Jump and Control Instructions</a>
section.<br /><br />
Example assembly notation: BNZ 1Eh -- Usually specifies a label or the
destination address
</div><br />

<span class="br"></span>
<a name="cpuformativ"><b>Format IV</b> - Middle-distance jump</a><br />
<div class="indent">
Instruction size: 32 bits<br />
Field layout:<br />
<pre>   15  10 9        0 31           16
  +------+--------------------------+
  |  op  |         disp26           |
  +------+--------------------------+</pre>
<div class="arg">op</div> - The instruction's opcode.<br />
<div class="arg">disp26</div> - A 26-bit, sign-extended displacement value
specifying the relative target address of the jump.<br /><br />
Example assembly notation: JR -46519 -- Usually specifies a label or the
destination address
</div><br />

<a name="cpuformatv"><b>Format V</b> - 3-operand</a><br />
<div class="indent">
Instruction size: 32 bits<br />
Field layout:<br />
<pre>   15  10 9   5 4   0 31            16
  +------+-----+-----+----------------+
  |  op  |reg2 |reg1 |     imm16      |
  +------+-----+-----+----------------+</pre>
<div class="arg">op</div> - The instruction's opcode.<br />
<div class="arg">reg2</div> - The 5-bit index (0-31) of the <i>destination</i>
register.<br />
<div class="arg">reg1</div> - The 5-bit index (0-31) of the <i>source</i>
register.<br />
<div class="arg">imm16</div> - The 16-bit value used as another source
operand.*<br /><br />
* - Depending on the instruction, the immediate value may be sign- or
zero-extended, or used as a 16-bit value.<br /><br />
Example assembly notation: ORI 3F20h, r1, r2
</div><br />

<a name="cpuformatvi"><b>Format VI</b> - Load/store</a><br />
<div class="indent">
Instruction size: 32 bits<br />
Field layout:<br />
<pre>   15  10 9   5 4   0 31            16
  +------+-----+-----+----------------+
  |  op  |reg2 |reg1 |     disp16     |
  +------+-----+-----+----------------+</pre>
<div class="arg">op</div> - The instruction's opcode.<br />
<div class="arg">reg2</div> - The 5-bit index (0-31) of the register to be used
as the destination for loading data or as the source for storing data.<br />
<div class="arg">reg1</div> - The 5-bit index (0-31) of the register containing
the base value of the address to load from/store to.<br />
<div class="arg">disp16</div> - A 16-bit, sign-extended displacement value
specifying the final address, relative to the base address specified by
<i>reg1</i>.<br /><br />
Example assembly notation: LD.W -16[r1], r2
</div><br />

<a name="cpuformatvii"><b>Format VII</b> - Extended instruction</a><br />
<div class="indent">
Instruction size: 32 bits<br />
Field layout:<br />
<pre>   15  10 9   5 4   0 31  26 25      16
  +------+-----+-----+------+----------+
  |  op  |reg2 |reg1 |subop |   RFU    |
  +------+-----+-----+------+----------+</pre>
<div class="arg">op</div> - The instruction's opcode.<br />
<div class="arg">reg2</div> - The 5-bit index (0-31) of the <i>destination</i>
register.<br />
<div class="arg">reg1</div> - The 5-bit index (0-31) of the <i>source</i>
register.<br />
<div class="arg">subop</div> - The extended opcode for this instruction.<br />
<div class="arg">RFU</div> - Reserved for future use.<br /><br />
Example assembly notation: MULF.S r1, r2
</div><br />



<h1><a name="cpumemoryandregistertransfers">CPU Memory and Register
Transfers</a></h1>

<a name="cpuregistertoregistertransfer"><b>Register/Immediate to Register
Transfer</b></a><br />
<pre>  010000  ----  <a href="#cpuformatii">II</a>  1  MOV     Move Immediate      reg2 = sign extend imm5
  000000  ----   <a href="#cpuformati">I</a>  1  MOV     Move Register       reg2 = reg1
  101000  ----   <a href="#cpuformatv">V</a>  1  MOVEA   Add Immediate       reg2 = reg1 + (sign extend imm16)
  101111  ----   <a href="#cpuformatv">V</a>  1  MOVHI   Add High Halfword   reg2 = reg1 + (imm16 << 16)
</pre>

The <i>MOVHI</i> and <i>MOVEA</i> instructions are provided for populating
registers with 32 bits of immediate data. Bear in mind that they perform
arithmetic addition, but do not affect the status flags.<br /><br />

<a name="cpuloadandinputregister"><b>Load and Input
Register</b></a><br />
<pre>  111000  ----  <a href="#cpuformatvi">VI</a>  3  IN.B   Input Byte       reg2 = zero extend (byte ptr [reg1 + disp16])
  111001  ----  <a href="#cpuformatvi">VI</a>  *  IN.H   Input Halfword   reg2 = zero extend (halfword ptr [reg1 + disp16])
  111011  ----  <a href="#cpuformatvi">VI</a>  *  IN.W   Input Word       reg2 = word ptr [reg1 + disp16]
  110000  ----  <a href="#cpuformatvi">VI</a>  *  LD.B   Load Byte        reg2 = sign extend (byte ptr [reg1 + disp16])
  110001  ----  <a href="#cpuformatvi">VI</a>  *  LD.H   Load Halfword    reg2 = sign extend (halfword ptr [reg1 + disp16])
  110011  ----  <a href="#cpuformatvi">VI</a>  *  LD.W   Load Word        reg2 = word ptr [reg1 + disp16]
</pre>
Note that *.H masks the lower bit of the address to 0, and *.W masks the
lower two bits to 0. This forces data to be read on a boundary of the same size
as the data being read.<br /><br />

The input instructions operate on CPU memory. The Virtual Boy does not have an
I/O bus. They operate similarly to the load instructions, but they will
zero-extend the values read rather than sign-extend them.<br /><br />

The number of cycles requred to complete a load or input instruction (except
for <i>IN.B</i>) depends on the context in which the instruction is
used.<br /><br />

The situations and cycle counts for load instructions are as follows:<br />
<div class="indent">
  1 cycle - When used after an instruction that takes many cycles and does not
conflict with the load instruction. <i>Editor's Note: How many is
"many"?</i><br />
  2 cycles - When following another load instruction on a 32-bit bus*<br />
  3 cycles - When used by itself on a 32-bit bus*<br />
  4 cycles - When following another load instruction on a 16-bit bus<br />
  5 cycles - When used by itself on a 16-bit bus
</div><br />
The situations and cycle counts for input instructions are as follows:<br />
<div class="indent">
  3 cycles - When used on a 32-bit bus*<br />
  5 cycles - When used on a 16-bit bus
</div><br />
* - Note that Virtual Boy always uses a 16-bit bus, so the 32-bit cycle counts
are only provided for the sake of completeness.<br /><br />

<a name="cpustoreandoutputregister"><b>Store and Output Register</b></a><br />
<pre>  111100  ----  <a href="#cpuformatvi">VI</a>  *  OUT.B   Output Byte       byte ptr [reg1 + disp16] = reg2 and 0xFF
  111101  ----  <a href="#cpuformatvi">VI</a>  *  OUT.H   Output Halfword   halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  111111  ----  <a href="#cpuformatvi">VI</a>  *  OUT.W   Output Word       word ptr [reg1 + disp16] = reg2
  110100  ----  <a href="#cpuformatvi">VI</a>  *  ST.B    Store Byte        byte ptr [reg1 + disp16] = reg2 and 0xFF
  110101  ----  <a href="#cpuformatvi">VI</a>  *  ST.H    Store Halfword    halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  110111  ----  <a href="#cpuformatvi">VI</a>  *  ST.W    Store Word        word ptr [reg1 + disp16] = reg2
</pre>
Note that *.H masks the lower bit of the address to 0, and *.W masks the lower
two bits to 0. This forces data to be written on a boundary of the same size as
the data being written.<br /><br />

The output instructions operate on CPU memory. The Virtual Boy does not have an
I/O bus. They operate in identical fashion to the store
instructions.<br /><br />

The number of cycles requred to complete a store or output instruction depends
on the context in which the instruction is used.<br /><br />

The situations and cycle counts are as follows (applies to both ST and
OUT):<br />
<div class="indent">
  1 cycle - The first two consecutive executions of the instruction<br />
  2 cycles - Subsequent executions of the instruction on a 32-bit bus*<br />
  4 cycles - Subsequent executions of the instruction on a 16-bit bus<br />
</div><br />
* - Note that Virtual Boy always uses a 16-bit bus, so the 32-bit cycle count
is only provided for the sake of completeness.<br /><br />



<h1><a name="cpuarithmeticbitwiseoperations">CPU Arithmetic/Bitwise
Operations</a></h1>

<a name="cpuarithmeticoperations"><b>Arithmetic Operations</b></a><br />
<pre>
  010001  cvsz  <a href="#cpuformatii">II</a>   1  ADD    Add Immediate       reg2 = reg2 + (sign extend imm5)
  000001  cvsz   <a href="#cpuformati">I</a>   1  ADD    Add Register        reg2 = reg2 + reg1
  101001  cvsz   <a href="#cpuformatv">V</a>   1  ADDI   Add Immediate       reg2 = reg1 + (sign extend imm16)
  010011  cvsz  <a href="#cpuformatii">II</a>   1  CMP    Compare Immediate   result = reg2 - (sign extend imm5)
  000011  cvsz   <a href="#cpuformati">I</a>   1  CMP    Compare Register    result = reg2 - reg1
  001001  -vsz   <a href="#cpuformati">I</a>  38  DIV    Divide Signed       r30 = reg2 mod reg1, reg2 = reg2 / reg1
  001011  -0sz   <a href="#cpuformati">I</a>  36  DIVU   Divide Unsigned     r30 = reg2 mod reg1, reg2 = reg2 / reg1
  001000  -vsz   <a href="#cpuformati">I</a>  13  MUL    Multipy Signed      result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  001010  -vsz   <a href="#cpuformati">I</a>  13  MULU   Multipy Unsigned    result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  000010  cvsz   <a href="#cpuformati">I</a>   1  SUB    Subtract            reg2 = reg2 - reg1
</pre>

There is no subtraction instruction that uses immediate data. If you need one,
use <i>ADD</i> or <i>ADDI</i> with a negative number.<br /><br />

The <i>CMP</i> instructions discard their output. Their only use is to modify
the status flags for the purpose of conditional execution.<br /><br />

The remainder of division operations is stored in register r30, as are the
upper 32 bits of multiplication operations. In both cases, the data is written
to r30 prior to the storage of the result in <i>reg2</i>.<br /><br />

Overflow for <i>DIV</i> can only occur if the maximum negative value
(0x80000000) is divided by -1 (0xFFFFFFFF). Should this occur, the result will
also be the maximum negative value, <i>r30</i> will become zero, and the
Overflow flag will be 1. Otherwise, the Overflow flag will be 0.<br /><br />

Overflow for <i>MUL</i> and <i>MULU</i> will occur if the entire 64-bit result
is not equal to the sign- or zero-extended (respectively) lower 32 bits of the
result. Otherwise, the Overflow flag will be 0.<br /><br />

The <i>DIV</i> and <i>DIVU</i> instructions can raise the Zero Division
<a href="#cpuexceptionsandinterrupts">exception</a>.<br /><br />

<a name="cpubitwiseoperations"><b>Bitwise Operations</b></a><br />
<pre>
  001101  -0sz   <a href="#cpuformati">I</a>  1  AND    And Register                       reg2 = reg2 and reg1
  101101  -00z   <a href="#cpuformatv">V</a>  1  ANDI   And Immediate                      reg2 = reg1 and (zero extend imm16)
  001111  -0sz   <a href="#cpuformati">I</a>  1  NOT    Not                                reg2 = not reg1
  001100  -0sz   <a href="#cpuformati">I</a>  1  OR     Or Register                        reg2 = reg2 or reg1
  101100  -0sz   <a href="#cpuformatv">V</a>  1  ORI    OR Immediate                       reg2 = reg1 or (zero extended imm16)
  010111  c0sz  <a href="#cpuformatii">II</a>  1  SAR    Shift Arithmetic Right Immediate   reg2 = reg2 >> (zero extend imm5) (sign-propagating)
  000111  c0sz   <a href="#cpuformati">I</a>  1  SAR    Shift Arithmetic Right Register    reg2 = reg2 >> reg1 (sign-propagating)
  010100  c0sz  <a href="#cpuformatii">II</a>  1  SHL    Shift Left Immediate               reg2 = reg2 << (zero extend imm5)
  000100  c0sz   <a href="#cpuformati">I</a>  1  SHL    Shift Left Register                reg2 = reg2 << reg1
  010101  c0sz  <a href="#cpuformatii">II</a>  1  SHR    Shift Right Immediate              reg2 = reg2 >> (zero extend imm5)
  000101  c0sz   <a href="#cpuformati">I</a>  1  SHR    Shift Right Register               reg2 = reg2 >> reg1
  001110  -0sz   <a href="#cpuformati">I</a>  1  XOR    Exclusive Or Register              reg2 = reg2 xor reg1
  101110  -0sz   <a href="#cpuformatv">V</a>  1  XORI   Exclusive Or Immediate             reg2 = reg1 xor (zero extend imm16)
</pre>

The arithmetic right shift is sign-propagating, meaning it makes a copy of the
high bit to shift in on the left rather than shifting in a zero like the normal
right shift does. This is primarily useful for manipulating signed
numbers.<br /><br />

When using a register to specify a bit shift amount, the lower 5 bits of the
register (<i>reg1</i> & 0x1F) are used as an unsigned integer.<br /><br />

For bit shift instructions, the <i>Carry</i> flag will be equal to the last
bit shifted out of the register. If the shift amount is 0, then <i>Carry</i>
will be 0.<br /><br />



<h1><a name="cpujumpandcontrolinstructions">CPU Jump and Control
Instructions</a></h1>

<a name="cpunormaljumps"><b>Normal Jumps</b></a><br />
<pre>  101011  ----  <a href="#cpuformativ">IV</a>   3  JAL   Jump and Link   r31 = PC + 4, PC = PC + disp26
  000110  ----   <a href="#cpuformati">I</a>   3  JMP   Jump register   PC = reg1
  101010  ----  <a href="#cpuformativ">IV</a>   3  JR    Jump relative   PC = PC + disp26
</pre>

Unlike most instructions, <i>JMP</i> operates off of its <i>reg1</i> field, not
its <i>reg2</i> field.<br /><br />

<a name="cpuconditionalbranches"><b>Conditional Branches</b></a><br /><br />

While there is only one actual conditional branch instruction, there are
assembly mnemonics for all varieties of its <i>cond</i> field. <i>Bcond</i>
conditions check the status of flags in the <a
href="#cpupswprogramstatusword">PSW</a> register.<br /><br />

The <i>Bcond</i> instruction has an opcode of 100, is stored in <a
href="#cpuformatiii">Format III</a>, and represents the following operations
according to the contents of its <i>cond</i> field:<br />
<pre>  0000  ----  BV       *  Branch if overflow                 if OV = 1                then PC = PC + disp9
  0001  ----  BC/BL    *  Branch if carry/less than          if CY = 1                then PC = PC + disp9
  0010  ----  BZ/BE    *  Branch if zero/equal               if Z = 1                 then PC = PC + disp9
  0011  ----  BNH      *  Branch if not higher (unsigned)    if (CY or Z) = 1         then PC = PC + disp9
  0100  ----  BN       *  Branch if negative                 if S = 1                 then PC = PC + disp9
  0101  ----  BR       *  Branch always                      PC = PC + disp9
  0110  ----  BLT      *  Branch if less than (signed)       if (S xor OV) = 1        then PC = PC + disp9
  0111  ----  BLE      *  Branch if less/equal (signed)      if ((S xor OV) or Z) = 1 then PC = PC + disp9
  1000  ----  BNV      *  Branch if not overflow             if OV = 0                then PC = PC + disp9
  1001  ----  BNC/BNL  *  Branch if not carry/less than      if CY = 0                then PC = PC + disp9
  1010  ----  BNZ/BNE  *  Branch if not zero/equal           if Z = 0                 then PC = PC + disp9
  1011  ----  BH       *  Branch if higher (unsigned)        if (CY or Z) = 0         then PC = PC + disp9
  1100  ----  BP       *  Branch if positive                 if S = 0                 then PC = PC + disp9
  1101  ----  NOP      *  No operation (never branch)        (do nothing)
  1110  ----  BGE      *  Branch if greater/equal (signed)   if (S xor OV) = 0        then PC = PC + disp9
  1111  ----  BGT      *  Branch if greater than (signed)    if ((S xor OV) or Z) = 0 then PC = PC + disp9</pre>
* - If the branch is not taken, <i>Bcond</i> takes 1 cycle to execute. Otherwise, 3
cycles are used. This means the NOP instruction only takes 1 cycle.<br /><br />

Note that there are some pairs of mnemonics, such as BC with BL, and BNZ with
BNE. Both mnemonics within a pair represent the same operation, and are likely
provided as a convenience for the programmer as it pertains to the context of
how the instruction is to be used. However, this makes it effectively
impossible to disassemble according to programmer intent. It's a matter of
preference at this point, but to disassemble to the BL, BE, BNL and BNE
variants are more likely to correspond with programmer logic than their
alternate representations.<br /><br />

<a name="cpucpucontrol"><b>CPU Control</b></a><br />
<pre>  011010  ----  <a href="#cpuformatii">II</a>   -  HALT   Halt CPU                     (wait for interrupt)
  011100  ****  <a href="#cpuformatii">II</a>   1  LDSR   Load into System Register    regID** = reg2
  011001  ****  <a href="#cpuformatii">II</a>  10  RETI   Return from Trap/IRQ         if NP = 1 then PC = FEPC, PSW = FEPSW
                                                              else         PC = EIPC, PSW = EIPSW
  011101  ----  <a href="#cpuformatii">II</a>   1  STSR   Store from System Register   reg2 = regID**
  011000  ----  <a href="#cpuformatii">II</a>  15  TRAP   Trap                         raise exception 0xFFA0 + vector*
</pre>

* - The <i>imm5</i> field of <i>TRAP</i> is used as a "trap vector", which is
an application-defined value representing the source of the exception as it is
stored in <a href="#cpuecrexceptioncauseregister">ECR</a>. Two exception
handlers can be defined for <i>TRAP</i>.<br />
** - The <i>imm5</i> field of the <i>LDSR</i> and <i>STSR</i> instructions
represents the <a href="#cpusystemregisters">system register</a> by ID; a value
called <i>regID</i>. The system register ID values are as follows:<br />
<div class="indent"><pre>
   0     EIPC   Exception/Interrupt PC
   1     EIPSW  Exception/Interrup PSW
   2     FEPC   Duplexed Exception PC
   3     FEPSW  Duplexed Exception PSW
   4     ECR*   Exception Cause Register
   5     PSW**  Program Status Word
   6     PIR*   Processor ID Register
   7     TKCW*  TasK Control Word
   8-23  (reserved***)
  24     CHCW   CacHe Control Word
  25     ADTRE  ADdress Trap Register for Execution
  26-31  (reserved***)
</pre>
* - These registers are read-only and cannot be used with <i>LDSR</i>.
However, attempting to do so will not trigger an exception; it will simply
have no effect.<br />
** - Program control of <a href="#cpupswprogramstatusword">PSW</a> can be done
with <i>LDSR</i> on a bit-for-bit correspondence with the contents of
<i>reg2</i>.<br />
*** - Accessing reserved registers does not have guaranteed operation.
<i>Editor's Note: No exception is defined, so perhaps junk is
assumed?</i><br />
</div><br />



<h1><a name="cpufloatingpointinstructions">CPU Floating-Point
Instructions</a></h1>

Instructions with an opcode field containing the bits 111110 are stored in <a
href="#cpuformatvii">Format VII</a> and contain a sub-opcode field. In the 
V810 family instruction set, only floating-point instructions are defined as
sub-opcodes of 111110, but Nintendo added a few instructions of their own here
as well. Although there is room for 64 sub-opcodes, only 12 are used on Virtual
Boy. The floating-point instructions are listed in this section, while the
Nintendo proprietary instructions are listed in the <a
href="#cpunintendoinstructions">CPU Nintendo Instructions</a> section. All
other values for the sub-opcode field represent invalid
instructions.<br /><br />

<b>Floating-Point Instructions</b>
<pre>  000100  c0szR--VUP  ADDF.S    9-28   Add Floating Short                reg2 = reg2 + reg1
  000000  c0szR-----  CMPF.S    7-10   Compare Floating Short            result = reg2 - reg1
  000011  -0szRI---P  CVT.SW    9-14   Convert Floating Short to Word    reg2 = (word) round(reg1)
  000010  c0sz-----P  CVT.WS    5-16   Convert Word to Floating Short    reg2 = (float) reg1
  000111  c0szRIZVUP  DIVF.S      44   Divide Floating Short             reg2 = reg2 / reg1
  000110  c0szR--VUP  MULF.S    8-30   Multiply Floating Short           reg2 = reg2 * reg1
  000101  c0szR--VUP  SUBF.S   12-28   Subtract Floating Short           reg2 = reg2 - reg1
  001011  -0szRI---P  TRNC.SW   8-14   Truncate Floating Short to Word   reg2 = (word) truncate(reg1)
</pre>

IMPORTANT: The floating-point program status flags can be set by these
instructions, but if the condition they represent is not met, they will not be
cleared by execution. If it's necessary to detect these flags as changes
occur, use the <a href="#cpucpucontrol"><i>LDSR</i></a> instruction first to
clear them.<br /><br />

To save space, this list uses one-letter abbreviations for the floating-point
program status flags in the <a href="#cpupswprogramstatusword">PSW</a>
register. The abbreviations correspond with the following flags in PSW:<br />
<pre>
  R   FRO   Floating-point reserved operand
  I   FIV   Floating-point invalid operation
  Z   FZD   Floating-point zero divide
  V   FOV   Floating-point overflow
  U   FUD   Floating-point underflow
  P   FPR   Floating-point precision degradation
</pre>

The <i>CMPF.S</i> instruction discards its output. Its only use is to modify
the status flags for the purpose of conditional execution.<br /><br />

The <i>CVT.SW</i> instruction's behavior is specified by the <a
href="#cputkcwtaskcontrolword">TKCW</a> register, but that register has a fixed
value on Virtual Boy to always specify rounding toward the nearest
integer.<br /><br />

The <i>TRNC.SW</i> instruction will truncate the float value at the point,
preserving the integer portion of the number.<br /><br />

The following chart shows which exceptions can be triggered by which
instructions:<br /><br />

<table>
<tr>
<td class="ex">&nbsp;</td>
<td class="op">ADDF.S</td><td class="op">CMPF.S</td><td class="op">CVT.SW</td>
<td class="op">CVT.WS</td><td class="op">DIVF.S</td><td class="op">MULF.S</td>
<td class="op">SUBF.S</td><td class="op">TRNC.SW</td>
</tr>
<tr>
<td class="ex">FRO<br /><i>Reserved Operand</i></td>
<td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&nbsp;</td>
<td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td>
</tr>
<tr>
<td class="ex">FOV<br /><i>Overflow</i></td>
<td>&#x2713;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
<td>&#x2713;</td><td>&#x2713;</td><td>&#x2713;</td><td>&nbsp;</td>
</tr>
<tr>
<td class="ex">FZD<br /><i>Zero Division</i></td>
<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
<td>&#x2713;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
</tr>
<tr>
<td class="ex">FIV<br /><i>Invalid Operation</i></td>
<td>&nbsp;</td><td>&nbsp;</td><td>&#x2713;</td><td>&nbsp;</td>
<td>&#x2713;</td><td>&nbsp;</td><td>&nbsp;</td><td>&#x2713;</td>
</tr>
</table>
<br/>

The <a href="#cputkcwtaskcontrolword">TKCW</a> register controls floating-point
exception masking, and it has a fixed value such that FUD (underflow) and FPR
(precision degradation) exceptions are permanently disabled.<br /><br />

Unfortunately, the specifics of how many CPU cycles are taken for various
floating-point operations have not been disclosed for the V810 family. The only
information provided consists of minimum and maximum cycle counts. For emulator
timing considerations, it would not be a bad idea to always use the maximum
cycle count, since it's guaranteed code won't run slower than that on a real
Virtual Boy.<br /><br />



<h1><a name="cpubitstringinstructions">CPU Bit String
Instructions</a></h1>

<a href="#cpuaboutbitstringinstructions">CPU About Bit String
Instructions</a><br />
<a href="#cpulistofbitstringinstructions">CPU List of Bit String
Instructions</a><br />
<br />



<h1><a name="cpuaboutbitstringinstructions">CPU About Bit String
Instructions</a></h1>

The bit string instructions on the V810 family processors are used to perform
batch processing on bit data in memory. Due to their potentially long execution
times, they can be aborted by interrupts and resumed once the interrupts have
been processed.<br /><br />

<a name="cpubitstringregisters"><b>Registers</b></a><br /><br />

All bit string instructions use registers r26-r30 to represent bit strings in
this manner:<br /><br />
<div class="indent">
<i>r30 - Source Word Address</i> - Specifies the starting word address of the
source string. The lowest 2 bits are masked to 0 before
execution.</i><br /><br />
<i>r29 - Destinaion Word Address</i> - Specifies the starting word address of
the destination string. The lowest 2 bits are masked to 0 before
execution.</i><br /><br />
<i>r28 - String Length</i> - Specifies the length of the string(s) by number of
bits. All 32 bits of this register are used as an unsigned value, meaning it
can represent anywhere from 0 to (2<sup>32</sup> - 1) bits of length (up to 512
MB minus one bit).<br /><br />
<i>r27 - Bit Offset in Source Word</i> - The index of the starting bit (0-31)
in the source word. The highest 27 bits are masked to 0 before
execution.</i><br /><br />
<i>r26 - Bit Offset in Destination Word</i> - The index of the starting bit
(0-31) in the destination word. The highest 27 bits are masked to 0 before
execution.</i>
</div><br />

Additionally, register r29 is used as output for the search instructions. This
can work because there is no destination string for searches.<br /><br />
<div class="indent">
<i>r29 - Number of Bits Skipped</i> - Specifies the number of bits skipped
during a search operation before the search completed. This register should be
set to 0 prior to using a search instruction.</i>
</div><br />

<a name="cpuabortingandresuming"><b>Aborting and Resuming</b></a><br /><br />

For all bit string instructions, registers r26-r30 are used as working
variables, such that the instructions can be aborted by interrupts and later
resumed. <i>Editor's Note: Will the CPU retain state information for bit string
instructions for each of normal execution, exception handling and duplexed
exception handling?</i><br /><br />

<a name="cpubitstringdirectionetc"><b>Direction and Bit
Order</b></a><br /><br />

Bit string instructions can operate either <i>upward</i> or <i>downward</i>.
The direction in which the address increases is considered upward, and the
direction in which the address decreases is considered downward.<br /><br />

Bits are read from words such that the most significant bit is in the upward
direction and the least significant bit is in the downward
direction.<br /><br />

Since words are read low byte first (little endian), bit strings can be
visualized as having address 0x00000000 on the right and all bits extend to
the left, in order of lowest to highest within each byte. In this context, the
upward direction would be left and the downward direction would be
right.<br /><br />

<a name="cpubitstringoverlappingbehavior"><b>Overlapping
Behavior</b></a><br /><br />

Bit string instructions will process source data intact; the output will never
recurse into the input. This is similar to how the standard C function
<i>memmove()</i> copies data to a temporary buffer before outputting: the
output never gets read back in as input.<br /><br />

For that reason, it is safe to use bit string instructions with overlapping
strings.<br /><br />



<h1><a name="cpulistofbitstringinstructions">CPU List of Bit String
Instructions</a></h1>

All bit string instructions have an opcode field containing the bits 011111,
are stored in <a href="#cpuformatii">Format II</a> and the <i>imm5</i> value is
used as a sub-opcode field. While there are 32 possible sub-opcodes, only 12
are used and the rest represent invalid instructions.<br /><br />

<a name="cpuarithmeticinstructions"><b>Arithmetic Instructions</b></a><br />
<pre>
  01001  ----  ANDBSU    And Bit String Upward                dest = dest and src
  01101  ----  ANDNBSU   And Not Bit String Upward            dest = dest and (not src)
  01011  ----  MOVBSU    Move Bit String Upward               dest = source
  01111  ----  NOTBSU    Not Bit String Upward                dest = not src
  01000  ----  ORBSU     Or Bit String Upward                 dest = dest or src
  01100  ----  ORNBSU    Or Not Bit String Upward             dest = dest or (not src)
  01010  ----  XORBSU    Exclusive Or Bit String Upward       dest = dest xor src 
  01110  ----  XORNBSU   Exclusive Or Not Bit String Upward   dest = dest xor (not src)
</pre>

Note that address overlaps can cause undesired operation by overwriting the
source before it can be written to the destination.<br /><br />

<a name="cpusearchinstructions"><b>Search Instructions</b></a><br />
<pre>
  00001  ---z  SCH0BSD   Search Bit 0 Downward    Search downward for a 0
  00000  ---z  SCH0BSU   Search Bit 0 Upward      Search upward for a 0
  00011  ---z  SCH1BSD   Search Bit 1 Downward    Search downward for a 1
  00010  ---z  SCH1BSU   Search Bit 1 Upward      Search upward for a 1
</pre>

If the search is not found, Z = 1. Otherwise, Z = 0.<br /><br />

<span class="br"></span>
<a name="cpunonsearchcycles"><b>Non-Search Instruction
Cycles</b></a><br /><br />

The number of cycles taken for arithmetic instructions depends on the
relationship between the word boundaries of the source and destination strings,
and the length of the string being manipulated. There are seven significant
situations to describe this relationship, called the <i>boundary condition</i>,
and they are named TYPE1 through TYPE7.<br /><br />

Let <i>N</i> be the number of words occupied by the source string (by address),
and <i>Ndest</i> the number of words occupied by the destination
string.<br /><br />

The boundary condition types are defined as follows:<br /><br />
<div class="indent">
if length = 0 then<br />
    <div class="indent">
    TYPE6
    </div>
else<br />
    <div class="indent">
    if (<i>N</i> = 1) and (<i>Ndest</i> = 1) and (source offset > destination
offset) then<br />
        <div class="indent">
        TYPE7
        </div>
    else if source offset = destination offset then<br />
        <div class="indent">
        if (source offset + length) mod 4 = 0 then -- Source ends on a word
boundary<br />
            <div class="indent">
            TYPE1
            </div>
        else<br />
            <div class="indent">
            TYPE2
            </div>
        end if
        </div>
    else<br />
        <div class="indent">
        if <i>N</i> = <i>Ndest</i> then<br />
            <div class="indent">
            if destinaton offset = 0 then -- Destination begins on a word
boundary<br />
                <div class="indent">
                TYPE3
                </div>
            else<br />
                <div class="indent">
                TYPE5
                </div>
            end if
            </div>
        else<br />
            <div class="indent">
            TYPE4
            </div>
        end if
        </div>
    end if
    </div>
end if
</div><br />



The following chart lists the execution times for arithmetic bit string
instructions. The specifics of how long instructions can take are only provided
for optimal conditions (cache hit, no bus waiting) in the V810 family
documentation. In practice, they will generally take slightly
longer.<br /><br />

<table>
<tr>
<td>Boundary</td>
<td colspan=2><i>N</i> = 1</td>
<td colspan=2><i>N</i> = 2</td>
<td colspan=2><i>N</i> > 2</td>
</tr>
<tr>
<td><u>Condition</u></td>
<td><u>32-bit bus*</u></td>
<td><u>16-bit bus</u></td>
<td><u>32-bit bus*</u></td>
<td><u>16-bit bus</u></td>
<td><u>32-bit bus*</u></td>
<td><u>16-bit bus</u></td>
</tr>
<tr>
<td>TYPE1</td><td>32</td><td>38</td><td>41</td><td>53</td>
<td>6<i>N</i> + 30</td><td>12<i>N</i> + 30</td>
</tr>
<tr>
<td>TYPE2</td><td>32</td><td>38</td><td>42</td><td>54</td>
<td>6<i>N</i> + 31</td><td>12<i>N</i> + 31</td>
</tr>
<tr>
<td>TYPE3</td><td>37</td><td>43</td><td>48</td><td>60</td>
<td>6<i>N</i> + 35</td><td>12<i>N</i> + 35</td>
</tr>
<tr>
<td>TYPE4</td><td>43</td><td>49</td><td>49</td><td>61</td>
<td>6<i>N</i> + 36</td><td>12<i>N</i> + 36</td>
</tr>
<tr>
<td>TYPE5</td><td>32</td><td>38</td><td>43</td><td>55</td>
<td>6<i>N</i> + 31</td><td>12<i>N</i> + 31</td>
</tr>
<tr>
<td>TYPE6</td><td>14</td><td>20</td><td>-</td><td>-</td>
<td>-</td><td>-</td>
</tr>
<tr>
<td>TYPE7</td><td>37</td><td>43</td><td>-</td><td>-</td>
<td>-</td><td>-</td>
</tr>
</table><br />

* - Note that Virtual Boy always uses a 16-bit bus, so the 32-bit cycle counts
are only provided for the sake of completeness.<br /><br />

<span class="br"></span>
<a name="cpusearchcycles"><b>Search Instruction Cycles</b></a><br /><br />

The number of cycles taken for search instructions depends on how many words
and bits within words are searched. The specifics of how long instructions can
take are only provided for optimal conditions (cache hit, no bus waiting) in
the V810 family documentation. In practice, they will generally take slightly
longer.<br /><br />

For the charts below, let the following values be defined:<br /><br />

<div class="indent">
<i>N</i> - The number of words occupied by the string (by address)<br />
<i>p</i> - Any word after the 2<sup>nd</sup> but before the
<i>N</i><sup>th</sup><br />
Start Bit - The source word's (1<sup>st</sup>) starting bit offset<br />
Found Bit - The bit offset of a match, which is located in the
<i>N</i><sup>th</sup> word
</div><br />

The following chart shows how many cycles are taken on a 16-bit bus for an
upward search:<br /><br />

<table>
<tr>
<td class="exhdr">Start Bit</td>
<td class="exhdr">Found Bit</td>
<td class="exhdr"><i>N</i></td>
<td class="exhdr">Found 1<sup>st</sup></td>
<td class="exhdr">Found 2<sup>nd</sup></td>
<td class="exhdr">Found <i>p</i><sup>th</sup></td>
<td class="exhdr">Found <i>N</i><sup>th</sup></td>
<td class="exhdr">Not Found</td>
</tr>
<tr>
<td>*</td><td>-</td><td>0</td>
<td>-</td><td>-</td><td>-</td><td>-</td>
<td>13</td>
</tr>
<tr>
<td>*</td><td>*</td><td>1</td>
<td>31</td><td>-</td><td>-</td><td>-</td>
<td>31</td>
</tr>
<tr>
<td>0</td><td>&lt; 31</td><td>2</td>
<td>40</td><td>43</td><td>-</td><td>-</td>
<td>44</td>
</tr>
<tr>
<td>> 0</td><td>&lt; 31</td><td>2</td>
<td>30</td><td>51</td><td>-</td><td>-</td>
<td>51</td>
</tr>
<tr>
<td>> 0</td><td>31</td><td>2</td>
<td>30</td><td>56</td><td>-</td><td>-</td>
<td>50</td>
</tr>
<tr>
<td>0</td><td>31</td><td>2</td>
<td>40</td><td>45</td><td>-</td><td>-</td>
<td>39</td>
</tr>
<tr>
<td>0</td><td>&lt; 31</td><td>> 2</td>
<td>40</td><td>45</td><td>3<i>p</i> + 35</td><td>3<i>N</i> + 33</td>
<td>3<i>N</i> + 34</td>
</tr>
<tr>
<td>> 0</td><td>&lt; 31</td><td>> 2</td>
<td>30</td><td>56</td><td>3<i>p</i> + 46</td><td>3<i>N</i> + 44</td>
<td>3<i>N</i> + 45</td>
</tr>
<tr>
<td>> 0</td><td>31</td><td>> 2</td>
<td>30</td><td>56</td><td>3<i>p</i> + 46</td><td>3<i>N</i> + 46</td>
<td>3<i>N</i> + 40</td>
</tr>
<tr>
<td>0</td><td>31</td><td>> 2</td>
<td>40</td><td>45</td><td>3<i>p</i> + 35</td><td>3<i>N</i> + 35</td>
<td>3<i>N</i> + 29</td>
</tr>
</table><br />

The following chart shows how many cycles are taken on a 16-bit bus for a
downward search:<br /><br />

<table>
<tr>
<td class="exhdr">Start Bit</td>
<td class="exhdr">Found Bit</td>
<td class="exhdr"><i>N</i></td>
<td class="exhdr">Found 1<sup>st</sup></td>
<td class="exhdr">Found 2<sup>nd</sup></td>
<td class="exhdr">Found <i>p</i><sup>th</sup></td>
<td class="exhdr">Found <i>N</i><sup>th</sup></td>
<td class="exhdr">Not Found</td>
</tr>
<tr>
<td>*</td><td>-</td><td>0</td>
<td>-</td><td>-</td><td>-</td><td>-</td>
<td>15</td>
</tr>
<tr>
<td>*</td><td>*</td><td>1</td>
<td>28</td><td>-</td><td>-</td><td>-</td>
<td>30</td>
</tr>
<tr>
<td>&lt; 31</td><td>0</td><td>2</td>
<td>33</td><td>52</td><td>-</td><td>-</td>
<td>54</td>
</tr>
<tr>
<td>&lt; 31</td><td>> 0</td><td>2</td>
<td>33</td><td>52</td><td>-</td><td>-</td>
<td>54</td>
</tr>
<tr>
<td>31</td><td>> 0</td><td>2</td>
<td>45</td><td>52</td><td>-</td><td>-</td>
<td>51</td>
</tr>
<tr>
<td>31</td><td>0</td><td>2</td>
<td>45</td><td>50</td><td>-</td><td>-</td>
<td>44</td>
</tr>
<tr>
<td>&lt; 31</td><td>0</td><td>> 2</td>
<td>33</td><td>59</td><td>3<i>p</i> + 49</td><td>3<i>N</i> + 49</td>
<td>3<i>N</i> + 43</td>
</tr>
<tr>
<td>&lt; 31</td><td>> 0</td><td>> 2</td>
<td>33</td><td>59</td><td>3<i>p</i> + 49</td><td>3<i>N</i> + 51</td>
<td>3<i>N</i> + 50</td>
</tr>
<tr>
<td>31</td><td>> 0</td><td>> 2</td>
<td>45</td><td>50</td><td>3<i>p</i> + 40</td><td>3<i>N</i> + 42</td>
<td>3<i>N</i> + 41</td>
</tr>
<tr>
<td>31</td><td>0</td><td>> 2</td>
<td>45</td><td>50</td><td>3<i>p</i> + 40</td><td>3<i>N</i> + 40</td>
<td>3<i>N</i> + 34</td>
</tr>
</table><br />

The Virtual Boy's bus always operates as 16-bit. Listed below are the 32-bit
execution times for the sake of completeness.<br /><br />

<span class="br"></span>
The following chart shows how many cycles are taken on a 32-bit bus for an
upward search:<br /><br />

<table>
<tr>
<td class="exhdr">Start Bit</td>
<td class="exhdr">Found Bit</td>
<td class="exhdr"><i>N</i></td>
<td class="exhdr">Found 1<sup>st</sup></td>
<td class="exhdr">Found 2<sup>nd</sup></td>
<td class="exhdr">Found <i>p</i><sup>th</sup></td>
<td class="exhdr">Found <i>N</i><sup>th</sup></td>
<td class="exhdr">Not Found</td>
</tr>
<tr>
<td>*</td><td>-</td><td>0</td>
<td>-</td><td>-</td><td>-</td><td>-</td>
<td>13</td>
</tr>
<tr>
<td>*</td><td>*</td><td>1</td>
<td>29</td><td>-</td><td>-</td><td>-</td>
<td>29</td>
</tr>
<tr>
<td>0</td><td>&lt; 31</td><td>2</td>
<td>38</td><td>39</td><td>-</td><td>-</td>
<td>40</td>
</tr>
<tr>
<td>> 0</td><td>&lt; 31</td><td>2</td>
<td>28</td><td>47</td><td>-</td><td>-</td>
<td>47</td>
</tr>
<tr>
<td>> 0</td><td>31</td><td>2</td>
<td>28</td><td>52</td><td>-</td><td>-</td>
<td>46</td>
</tr>
<tr>
<td>0</td><td>31</td><td>2</td>
<td>38</td><td>41</td><td>-</td><td>-</td>
<td>35</td>
</tr>
<tr>
<td>0</td><td>&lt; 31</td><td>> 2</td>
<td>38</td><td>41</td><td>3<i>p</i> + 35</td><td>3<i>N</i> + 33</td>
<td>3<i>N</i> + 34</td>
</tr>
<tr>
<td>> 0</td><td>&lt; 31</td><td>> 2</td>
<td>28</td><td>52</td><td>3<i>p</i> + 46</td><td>3<i>N</i> + 44</td>
<td>3<i>N</i> + 45</td>
</tr>
<tr>
<td>> 0</td><td>31</td><td>> 2</td>
<td>28</td><td>52</td><td>3<i>p</i> + 46</td><td>3<i>N</i> + 46</td>
<td>3<i>N</i> + 40</td>
</tr>
<tr>
<td>0</td><td>31</td><td>> 2</td>
<td>38</td><td>41</td><td>3<i>p</i> + 35</td><td>3<i>N</i> + 35</td>
<td>3<i>N</i> + 29</td>
</tr>
</table><br />

The following chart shows how many cycles are taken on a 32-bit bus for a
downward search:<br /><br />

<table>
<tr>
<td class="exhdr">Start Bit</td>
<td class="exhdr">Found Bit</td>
<td class="exhdr"><i>N</i></td>
<td class="exhdr">Found 1<sup>st</sup></td>
<td class="exhdr">Found 2<sup>nd</sup></td>
<td class="exhdr">Found <i>p</i><sup>th</sup></td>
<td class="exhdr">Found <i>N</i><sup>th</sup></td>
<td class="exhdr">Not Found</td>
</tr>
<tr>
<td>*</td><td>-</td><td>0</td>
<td>-</td><td>-</td><td>-</td><td>-</td>
<td>15</td>
</tr>
<tr>
<td>*</td><td>*</td><td>1</td>
<td>26</td><td>-</td><td>-</td><td>-</td>
<td>28</td>
</tr>
<tr>
<td>&lt; 31</td><td>0</td><td>2</td>
<td>31</td><td>48</td><td>-</td><td>-</td>
<td>50</td>
</tr>
<tr>
<td>&lt; 31</td><td>> 0</td><td>2</td>
<td>31</td><td>48</td><td>-</td><td>-</td>
<td>50</td>
</tr>
<tr>
<td>31</td><td>> 0</td><td>2</td>
<td>43</td><td>48</td><td>-</td><td>-</td>
<td>47</td>
</tr>
<tr>
<td>31</td><td>0</td><td>2</td>
<td>43</td><td>46</td><td>-</td><td>-</td>
<td>40</td>
</tr>
<tr>
<td>&lt; 31</td><td>0</td><td>> 2</td>
<td>31</td><td>55</td><td>3<i>p</i> + 49</td><td>3<i>N</i> + 49</td>
<td>3<i>N</i> + 43</td>
</tr>
<tr>
<td>&lt; 31</td><td>> 0</td><td>> 2</td>
<td>31</td><td>55</td><td>3<i>p</i> + 49</td><td>3<i>N</i> + 51</td>
<td>3<i>N</i> + 50</td>
</tr>
<tr>
<td>31</td><td>> 0</td><td>> 2</td>
<td>43</td><td>46</td><td>3<i>p</i> + 40</td><td>3<i>N</i> + 42</td>
<td>3<i>N</i> + 41</td>
</tr>
<tr>
<td>31</td><td>0</td><td>> 2</td>
<td>43</td><td>46</td><td>3<i>p</i> + 40</td><td>3<i>N</i> + 40</td>
<td>3<i>N</i> + 34</td>
</tr>
</table><br />



<h1><a name="cpumiscinstructions">CPU Miscellaneous Instructions</a></h1>

<b>Miscellaneous Instructions</b><br />
<pre>
  111010  cvsz  <a href="#cpuformatvi">VI</a>  26  CAXI   Compare and Exchange Interlocked   (<a href="#cpucaxi">See below</a>)
  010010  ----  <a href="#cpuformatii">II</a>   1  SETF   Set Flag Condition                 reg2 = 1 if condition* true, 0 otherwise
</pre>
* - The <i>imm5</i> field of <i>SETF</i> specifies a condition to check for in
the <a href="#cpupswprogramstatusword">PSW</a> register. The condition values
match those used in the <a href="#cpuconditionalbranches"><i>Bcond</i></a>
instruction, and are as follows:<br />
<div class="indent"><pre>
  0000   V       OV = 1
  0001   C/L     CY = 1
  0010   Z       Z = 1
  0011   NH      (CY or Z) = 1
  0100   S/N     S = 1
  0101   T       (always 1)
  0110   LT      (S xor OV) = 1
  0111   LE      ((S xor OV) or Z) = 1
  1000   NV      OV = 0
  1001   NC/NL   CY = 0
  1010   NZ      Z = 0
  1011   H       (CY or Z) = 0
  1100   NS/P    S = 0
  1101   F       (always 0)
  1110   GE      (S xor OV) = 0
  1111   GT      ((S xor OV) or Z) = 0
 10000+  (undefined)*
</pre>
As with <i>Bcond</i>, there are multiple assembly mnemonics for some
conditions, but they represent the same status.<br /><br />

<i>* - Editor's Note: What happens if you use these?</i>
</div><br />

<a name="cpucaxi"><b>CAXI</b></a><br /><br />
The purpose of the <i>CAXI</i> instruction is to synchronize multiple
processors by implementing a simple mutex mechanism. Three parameters are
passed to the instruction: a memory address, a value to check for when a lock
is desired, and a value to write to the address if the lock succeeds. All
processors that share the given resource should check that address against
the same value.<br /><br />

The <i>CAXI</i> instruction has the following parameters:<br />
<div class="indent">
<div class="arg">reg1</div> - The base value of the address to check<br />
<div class="arg">disp16</div> - The address relative to the base address<br />
<div class="arg">reg2</div> - The value to check at the resulting address<br />
<div class="arg" style="font-style: normal;"><b>r30</b></div> - The value to
write to the address if it matches <i>reg2</i>
</div><br />

The address, calculated as <i>reg1</i> + <i>disp16</i>, is called the
<i>lock word</i>. It has the lowest two bits masked to zero, forcing the lock
address to start on a word boundary.<br /><br />

Let <i>lock</i> be the value of the lock word. During execution, <i>CAXI</i>
will perform a comparison--<a href="#cpuarithmeticoperations"><i>CMP</i></a>
with <i>reg2</i> - <i>lock</i>--and when it completes, <i>lock</i> will be
stored into <i>reg2</i>. If <i>lock</i> was equal to <i>reg2</i>, then the
value in <b>r30</b> will have been written to the lock word. The program can
quickly check what happened by examining the Z flag of the status register and
branching accordingly.<br /><br />

To prevent bus conflicts, <i>CAXI</i> locks the bus during execution, which
keeps other processors from accessing memory while it executes. This also
eliminates race conditions on the lock word.<br /><br />

Since Virtual Boy only has one processor, the implementation of the <i>CAXI</i>
instruction is roughly equivalent to this:<br />
<pre>
  addr = (reg1 + disp16) AND -4
  lock = word ptr [addr]
  compare reg2 - lock
  reg2 = lock
  if Z = 1 then word ptr [addr] = r30
</pre>

If <i>CAXI</i> is used on a 32-bit bus, it will take 22 cycles. On 16-bits, it
will take 26. Note that Virtual Boy always uses a 16-bit bus, so the 32-bit
cycle count is only provided for the sake of completeness.<br /><br />



<h1><a name="cpunintendoinstructions">CPU Nintendo Instructions</a></h1>

When Nintendo adapted the V810 for use with the Virtual Boy, they introduced a
handful of proprietary instructions for auxiliary functionality. They did not
specify cycle counts, however, so that information may not be 100%
accurate.<br /><br />

Of the 6 instructions Nintendo added to the V810 instruction set, 2 of them
have their own opcodes and the other 4 occupy otherwise-unused sub-opcodes of
the floating-point instructions.<br /><br />

<a name="cpunvcstandalone"><b>Standalone Instructions</b></a><br />
<pre>  010110  ----  <a href="#cpuformatii">II</a>  1  CLI   Clear interrupt disable flag   I = 0
  011110  ----  <a href="#cpuformatii">II</a>  1  SEI   Set interrupt disable flag     I = 1
</pre>

Ordinarily, the interrupt disable flag in the status register can only be set
and cleared via the <a href="#cpucpucontrol"><i>LDSR</i></a> instruction, but
Nintendo implemented these two instructions that were present in the
instruction sets for NES and SNES.<br /><br />

Instructions with an opcode field containing the bits 111110 are stored in <a
href="#cpuformatvii">Format VII</a> and contain a sub-opcode field. For more
information, refer to the <a href="#cpufloatingpointinstructions">CPU
Floating-Point Instructions</a> section. The remaining Nintendo instructions
occupy sub-opcodes of 111110.<br /><br />

<a name="cpunvcsubopcodes"><b>Sub-Opcode Instructions</b></a>
<pre>  001100  ----  9  MPYHW   Multiply Halfword Signed*   reg2 = reg2 * reg1
  001010  ----  1  REV     Reverse Bits                reg2 = bit_reverse reg1
  001000  ----  1  XB      Swap Low Bytes**            reg2 bytes zyxw = zywx
  001001  ----  1  XH      Swap Halfwords**            reg2 bytes zyxw = xwzy
</pre>

* - This instruction treats the values in <i>reg1</i> and <i>reg2</i> as
signed halfwords. For this reason, the result will be incorrect if the upper
16 bits of each operand do not match the value of bit 15 within that
operand.<br /><br />

** - These instructions must specify r0 for their <i>reg1</i> field. Operation
is not guaranteed if any other register is specified. <i>Editor's Note: But
what exactly would happen?</i><br /><br />



<h1><a name="cpuinstructionsbyopcode">CPU List of Instructions by
Opcode</a></h1>

<b>Normal Instructions</b><br />
<pre>  000000    <a href="#cpuformati">I</a>  <a href="#cpuregistertoregistertransfer">MOV</a>     Move Register                      reg2 = reg1
  000001    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">ADD</a>     Add Register                       reg2 = reg2 + reg1
  000010    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">SUB</a>     Subtract                           reg2 = reg2 - reg1
  000011    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">CMP</a>     Compare Register                   result = reg2 - reg1
  000100    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SHL</a>     Shift Left Register                reg2 = reg2 << reg1
  000101    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SHR</a>     Shift Right Register               reg2 = reg2 >> reg1
  000110    <a href="#cpuformati">I</a>  <a href="#cpunormaljumps">JMP</a>     Jump register                      PC = reg1
  000111    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SAR</a>     Shift Arithmetic Right Register    reg2 = reg2 >> reg1 (sign-propagating)
  001000    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">MUL</a>     Multipy Signed                     result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  001001    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">DIV</a>     Divide Signed                      r30 = reg2 mod reg1, reg2 = reg2 / reg1
  001010    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">MULU</a>    Multipy Unsigned                   result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  001011    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">DIVU</a>    Divide Unsigned                    r30 = reg2 mod reg1, reg2 = reg2 / reg1
  001100    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">OR</a>      Or Register                        reg2 = reg2 or reg1
  001101    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">AND</a>     And Register                       reg2 = reg2 and reg1
  001110    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">XOR</a>     Exclusive Or Register              reg2 = reg2 xor reg1
  001111    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">NOT</a>     Not                                reg2 = not reg1
  010000   <a href="#cpuformatii">II</a>  <a href="#cpuregistertoregistertransfer">MOV</a>     Move Immediate                     reg2 = sign extend imm5
  010001   <a href="#cpuformatii">II</a>  <a href="#cpuarithmeticoperations">ADD</a>     Add Immediate                      reg2 = reg2 + (sign extend imm5)
  010010   <a href="#cpuformatii">II</a>  <a href="#cpumiscinstructions">SETF</a>    Set Flag Condition                 reg2 = 1 if condition true, 0 otherwise
  010011   <a href="#cpuformatii">II</a>  <a href="#cpuarithmeticoperations">CMP</a>     Compare Immediate                  result = reg2 - (sign extend imm5)
  010100   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SHL</a>     Shift Left Immediate               reg2 = reg2 << (zero extend imm5)
  010101   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SHR</a>     Shift Right Immediate              reg2 = reg2 >> (zero extend imm5)
  010110   <a href="#cpuformatii">II</a>  <a href="#cpunintendoinstructions">CLI</a>     Clear interrupt disable flag       I = 0
  010111   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SAR</a>     Shift Arithmetic Right Immediate   reg2 = reg2 >> (zero extend imm5) (sign-propagating)
  011000   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">TRAP</a>    Trap                               raise exception 0xFFA0 + vector
  011001   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">RETI</a>    Return from Trap/IRQ               (See section)
  011010   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">HALT</a>    Halt CPU                           (wait for interrupt)
  011011    !          <b>== ILLEGAL OPCODE ==</b>
  011100   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">LDSR</a>    Load into System Register          regID = reg2
  011101   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">STSR</a>    Store from System Register         reg2 = regID
  011110   <a href="#cpuformatii">II</a>  <a href="#cpunintendoinstructions">SEI</a>     Set interrupt disable flag         I = 1
  011111   <a href="#cpuformatii">II</a>  *       (<a href="#cpubitstringinstructions">Bit string instructions</a>)          (See section)
  100     <a href="#cpuformatiii">III</a>  <a href="#cpuconditionalbranches">Bcond</a>   Conditional branches               (See section)
  101000    <a href="#cpuformatv">V</a>  <a href="#cpuregistertoregistertransfer">MOVEA</a>   Add Immediate                      reg2 = reg1 + (sign extend imm16)
  101001    <a href="#cpuformatv">V</a>  <a href="#cpuarithmeticoperations">ADDI</a>    Add Immediate                      reg2 = reg1 + (sign extend imm16)
  101010   <a href="#cpuformativ">IV</a>  <a href="#cpunormaljumps">JR</a>      Jump relative                      PC = PC + disp26
  101011   <a href="#cpuformativ">IV</a>  <a href="#cpunormaljumps">JAL</a>     Jump and Link                      r31 = PC + 4, PC = PC + disp26
  101100    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">ORI</a>     OR Immediate                       reg2 = reg1 or (zero extended imm16)
  101101    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">ANDI</a>    And Immediate                      reg2 = reg1 and (zero extend imm16)
  101110    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">XORI</a>    Exclusive Or Immediate             reg2 = reg1 xor (zero extend imm16)
  101111    <a href="#cpuformatv">V</a>  <a href="#cpuregistertoregistertransfer">MOVHI</a>   Add High Halfword                  reg2 = reg1 + (imm16 << 16)
  110000   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.B</a>    Load Byte                          reg2 = sign extend (byte ptr [reg1 + disp16])
  110001   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.H</a>    Load Halfword                      reg2 = sign extend (halfword ptr [reg1 + disp16])
  110010    !          <b>== ILLEGAL OPCODE ==</b>
  110011   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.W</a>    Load Word                          reg2 = word ptr [reg1 + disp16]
  110100   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.B</a>    Store Byte                         byte ptr [reg1 + disp16] = reg2 and 0xFF
  110101   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.H</a>    Store Halfword                     halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  110110    !          <b>== ILLEGAL OPCODE ==</b>
  110111   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.W</a>    Store Word                         word ptr [reg1 + disp16] = reg2
  111000   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.B</a>    Input Byte                         reg2 = zero extend (byte ptr [reg1 + disp16])
  111001   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.H</a>    Input Halfword                     reg2 = zero extend (halfword ptr [reg1 + disp16])
  111010   <a href="#cpuformatvi">VI</a>  <a href="#cpumiscinstructions">CAXI</a>    Compare and Exchange Interlocked   (See section)
  111011   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.W</a>    Input Word                         reg2 = word ptr [reg1 + disp16]
  111100   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.B</a>   Output Byte                        byte ptr [reg1 + disp16] = reg2 and 0xFF
  111101   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.H</a>   Output Halfword                    halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  111110  <a href="#cpuformatvii">VII</a>  *       (<a href="#cpufloatingpointinstructions">Floating-point instructions</a>)      (See section)
  111111   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.W</a>   Output Word                        word ptr [reg1 + disp16] = reg2
</pre>

<b><a href="#cpubitstringinstructions">Bit String</a> Instructions</b> - Opcode
= 011111<br />
<pre>  00000  SCH0BSU   Search Bit 0 Upward                  Search upward for a 0
  00001  SCH0BSD   Search Bit 0 Downward                Search downward for a 0
  00010  SCH1BSU   Search Bit 1 Upward                  Search upward for a 1
  00011  SCH1BSD   Search Bit 1 Downward                Search downward for a 1
  00100-00111      <b>== ILLEGAL OPCODE ==</b>
  01000  ORBSU     Or Bit String Upward                 dest = dest or src
  01001  ANDBSU    And Bit String Upward                dest = dest and src
  01010  XORBSU    Exclusive Or Bit String Upward       dest = dest xor src
  01011  MOVBSU    Move Bit String Upward               dest = source
  01100  ORNBSU    Or Not Bit String Upward             dest = dest or (not src)
  01101  ANDNBSU   And Not Bit String Upward            dest = dest and (not src)
  01110  XORNBSU   Exclusive Or Not Bit String Upward   dest = dest xor (not src)
  01111  NOTBSU    Not Bit String Upward                dest = not src
  10000-11111      <b>== ILLEGAL OPCODE ==</b>
</pre>

<span class="br"></span>
<b><a href="#cpufloatingpointinstructions">Floating-Point</a> and <a
href="#cpunintendoinstructions">Nintendo</a> Instructions</b> - Opcode =
111110<br />
<pre>  000000  CMPF.S    Compare Floating Short            result = reg2 - reg1
  000001            <b>== ILLEGAL OPCODE ==</b>
  000010  CVT.WS    Convert Word to Floating Short    reg2 = float reg1
  000011  CVT.SW    Convert Floating Short to Word    reg2 = convert reg1
  000100  ADDF.S    Add Floating Short                reg2 = reg2 + reg1
  000101  SUBF.S    Subtract Floating Short           reg2 = reg2 - reg1
  000110  MULF.S    Multiply Floating Short           reg2 = reg2 * reg1
  000111  DIVF.S    Divide Floating Short             reg2 = reg2 / reg1
  001000  XB        Swap Low Bytes                    reg2 bytes zyxw = zywx
  001001  XH        Swap Halfwords                    reg2 bytes zyxw = xwzy
  001010  REV       Reverse Bits                      reg2 = bit_reverse reg1
  001011  TRNC.SW   Truncate Floating Short to Word   reg2 = truncate reg1
  001100  MPYHW     Multiply Halfword Signed          reg2 = reg2 * reg1
  001101-111111     <b>== ILLEGAL OPCODE ==</b>
</pre><br />



<h1><a name="cpuinstructionsbymnemonic">CPU List of Instructions by
Mnemonic</a></h1>

<b>Normal Instructions</b><br />
<pre>
  010001   <a href="#cpuformatii">II</a>  <a href="#cpuarithmeticoperations">ADD</a>     Add Immediate                      reg2 = reg2 + (sign extend imm5)
  000001    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">ADD</a>     Add Register                       reg2 = reg2 + reg1
  101001    <a href="#cpuformatv">V</a>  <a href="#cpuarithmeticoperations">ADDI</a>    Add Immediate                      reg2 = reg1 + (sign extend imm16)
  001101    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">AND</a>     And Register                       reg2 = reg2 and reg1
  101101    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">ANDI</a>    And Immediate                      reg2 = reg1 and (zero extend imm16)
  100     <a href="#cpuformatiii">III</a>  <a href="#cpuconditionalbranches">Bcond</a>   Conditional branches               (See section)
  111010   <a href="#cpuformatvi">VI</a>  <a href="#cpumiscinstructions">CAXI</a>    Compare and Exchange Interlocked   (See section)
  010110   <a href="#cpuformatii">II</a>  <a href="#cpunintendoinstructions">CLI</a>     Clear interrupt disable flag       I = 0
  010011   <a href="#cpuformatii">II</a>  <a href="#cpuarithmeticoperations">CMP</a>     Compare Immediate                  result = reg2 - (sign extend imm5)
  000011    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">CMP</a>     Compare Register                   result = reg2 - reg1
  001001    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">DIV</a>     Divide Signed                      r30 = reg2 mod reg1, reg2 = reg2 / reg1
  001011    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">DIVU</a>    Divide Unsigned                    r30 = reg2 mod reg1, reg2 = reg2 / reg1
  011010   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">HALT</a>    Halt CPU                           (wait for interrupt)
  111000   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.B</a>    Input Byte                         reg2 = zero extend (byte ptr [reg1 + disp16])
  111001   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.H</a>    Input Halfword                     reg2 = zero extend (halfword ptr [reg1 + disp16])
  111011   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.W</a>    Input Word                         reg2 = word ptr [reg1 + disp16]
  101011   <a href="#cpuformativ">IV</a>  <a href="#cpunormaljumps">JAL</a>     Jump and Link                      r31 = PC + 4, PC = PC + disp26
  000110    <a href="#cpuformati">I</a>  <a href="#cpunormaljumps">JMP</a>     Jump register                      PC = reg1
  101010   <a href="#cpuformativ">IV</a>  <a href="#cpunormaljumps">JR</a>      Jump relative                      PC = PC + disp26
  110000   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.B</a>    Load Byte                          reg2 = sign extend (byte ptr [reg1 + disp16])
  110001   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.H</a>    Load Halfword                      reg2 = sign extend (halfword ptr [reg1 + disp16])
  110011   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.W</a>    Load Word                          reg2 = word ptr [reg1 + disp16]
  011100   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">LDSR</a>    Load into System Register          regID = reg2
  010000   <a href="#cpuformatii">II</a>  <a href="#cpuregistertoregistertransfer">MOV</a>     Move Immediate                     reg2 = sign extend imm5
  000000    <a href="#cpuformati">I</a>  <a href="#cpuregistertoregistertransfer">MOV</a>     Move Register                      reg2 = reg1
  101000    <a href="#cpuformatv">V</a>  <a href="#cpuregistertoregistertransfer">MOVEA</a>   Add Immediate                      reg2 = reg1 + (sign extend imm16)
  101111    <a href="#cpuformatv">V</a>  <a href="#cpuregistertoregistertransfer">MOVHI</a>   Add High Halfword                  reg2 = reg1 + (imm16 << 16)
  001000    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">MUL</a>     Multipy Signed                     result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  001010    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">MULU</a>    Multipy Unsigned                   result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  001111    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">NOT</a>     Not                                reg2 = not reg1
  111100   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.B</a>   Output Byte                        byte ptr [reg1 + disp16] = reg2 and 0xFF
  111101   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.H</a>   Output Halfword                    halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  111111   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.W</a>   Output Word                        word ptr [reg1 + disp16] = reg2
  001100    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">OR</a>      Or Register                        reg2 = reg2 or reg1
  101100    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">ORI</a>     OR Immediate                       reg2 = reg1 or (zero extended imm16)
  011001   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">RETI</a>    Return from Trap/IRQ               (See section)
  010111   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SAR</a>     Shift Arithmetic Right Immediate   reg2 = reg2 >> (zero extend imm5) (sign-propagating)
  000111    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SAR</a>     Shift Arithmetic Right Register    reg2 = reg2 >> reg1 (sign-propagating)
  011110   <a href="#cpuformatii">II</a>  <a href="#cpunintendoinstructions">SEI</a>     Set interrupt disable flag         I = 1
  010010   <a href="#cpuformatii">II</a>  <a href="#cpumiscinstructions">SETF</a>    Set Flag Condition                 reg2 = 1 if condition true, 0 otherwise
  010100   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SHL</a>     Shift Left Immediate               reg2 = reg2 << (zero extend imm5)
  000100    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SHL</a>     Shift Left Register                reg2 = reg2 << reg1
  010101   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SHR</a>     Shift Right Immediate              reg2 = reg2 >> (zero extend imm5)
  000101    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SHR</a>     Shift Right Register               reg2 = reg2 >> reg1
  110100   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.B</a>    Store Byte                         byte ptr [reg1 + disp16] = reg2 and 0xFF
  110101   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.H</a>    Store Halfword                     halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  110111   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.W</a>    Store Word                         word ptr [reg1 + disp16] = reg2
  011101   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">STSR</a>    Store from System Register         reg2 = regID
  000010    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">SUB</a>     Subtract                           reg2 = reg2 - reg1
  011000   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">TRAP</a>    Trap                               raise exception 0xFFA0 + vector
  101110    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">XORI</a>    Exclusive Or Immediate             reg2 = reg1 xor (zero extend imm16)
  001110    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">XOR</a>     Exclusive Or Register              reg2 = reg2 xor reg1
  011111   <a href="#cpuformatii">II</a>  *       (<a href="#cpubitstringinstructions">Bit string instructions</a>)          (See section)
  111110  <a href="#cpuformatvii">VII</a>  *       (<a href="#cpufloatingpointinstructions">Floating-point instructions</a>)      (See section)
</pre>

<b><a href="#cpubitstringinstructions">Bit String</a> Instructions</b> - Opcode
= 011111<br />
<pre>
  01001  ANDBSU    And Bit String Upward                dest = dest and src
  01101  ANDNBSU   And Not Bit String Upward            dest = dest and (not src)
  01011  MOVBSU    Move Bit String Upward               dest = source
  01111  NOTBSU    Not Bit String Upward                dest = not src
  01000  ORBSU     Or Bit String Upward                 dest = dest or src
  01100  ORNBSU    Or Not Bit String Upward             dest = dest or (not src)
  00001  SCH0BSD   Search Bit 0 Downward                Search downward for a 0
  00000  SCH0BSU   Search Bit 0 Upward                  Search upward for a 0
  00011  SCH1BSD   Search Bit 1 Downward                Search downward for a 1
  00010  SCH1BSU   Search Bit 1 Upward                  Search upward for a 1
  01010  XORBSU    Exclusive Or Bit String Upward       dest = dest xor src
  01110  XORNBSU   Exclusive Or Not Bit String Upward   dest = dest xor (not src)
</pre>

<span class="br"></span>
<b><a href="#cpufloatingpointinstructions">Floating-Point</a> and <a
href="#cpunintendoinstructions">Nintendo</a> Instructions</b> - Opcode =
111110<br />
<pre>
  000100  ADDF.S    Add Floating Short                reg2 = reg2 + reg1
  000000  CMPF.S    Compare Floating Short            result = reg2 - reg1
  000011  CVT.SW    Convert Floating Short to Word    reg2 = convert reg1
  000010  CVT.WS    Convert Word to Floating Short    reg2 = float reg1
  000111  DIVF.S    Divide Floating Short             reg2 = reg2 / reg1
  001100  MPYHW     Multiply Halfword Signed          reg2 = reg2 * reg1
  000110  MULF.S    Multiply Floating Short           reg2 = reg2 * reg1
  001010  REV       Reverse Bits                      reg2 = bit_reverse reg1
  000101  SUBF.S    Subtract Floating Short           reg2 = reg2 - reg1
  001011  TRNC.SW   Truncate Floating Short to Word   reg2 = truncate reg1
  001000  XB        Swap Low Bytes                    reg2 bytes zyxw = zywx
  001001  XH        Swap Halfwords                    reg2 bytes zyxw = xwzy
</pre><br />



<h1><a name="cpuinstructionsbyformat">CPU List of Instructions by
Format</a></h1>

<b>Normal Instructions</b><br />
<pre>
  000001    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">ADD</a>     Add Register                       reg2 = reg2 + reg1
  001101    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">AND</a>     And Register                       reg2 = reg2 and reg1
  000011    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">CMP</a>     Compare Register                   result = reg2 - reg1
  001001    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">DIV</a>     Divide Signed                      r30 = reg2 mod reg1, reg2 = reg2 / reg1
  001011    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">DIVU</a>    Divide Unsigned                    r30 = reg2 mod reg1, reg2 = reg2 / reg1
  000110    <a href="#cpuformati">I</a>  <a href="#cpunormaljumps">JMP</a>     Jump register                      PC = reg1
  000000    <a href="#cpuformati">I</a>  <a href="#cpuregistertoregistertransfer">MOV</a>     Move Register                      reg2 = reg1
  001000    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">MUL</a>     Multipy Signed                     result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  001010    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">MULU</a>    Multipy Unsigned                   result = reg2 * reg1, r30 = result high 32, reg2 = result low 32
  001111    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">NOT</a>     Not                                reg2 = not reg1
  001100    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">OR</a>      Or Register                        reg2 = reg2 or reg1
  000111    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SAR</a>     Shift Arithmetic Right Register    reg2 = reg2 >> reg1 (sign-propagating)
  000100    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SHL</a>     Shift Left Register                reg2 = reg2 << reg1
  000101    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">SHR</a>     Shift Right Register               reg2 = reg2 >> reg1
  000010    <a href="#cpuformati">I</a>  <a href="#cpuarithmeticoperations">SUB</a>     Subtract                           reg2 = reg2 - reg1
  001110    <a href="#cpuformati">I</a>  <a href="#cpubitwiseoperations">XOR</a>     Exclusive Or Register              reg2 = reg2 xor reg1
  010001   <a href="#cpuformatii">II</a>  <a href="#cpuarithmeticoperations">ADD</a>     Add Immediate                      reg2 = reg2 + (sign extend imm5)
  010110   <a href="#cpuformatii">II</a>  <a href="#cpunintendoinstructions">CLI</a>     Clear interrupt disable flag       I = 0
  011010   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">HALT</a>    Halt CPU                           (wait for interrupt)
  010011   <a href="#cpuformatii">II</a>  <a href="#cpuarithmeticoperations">CMP</a>     Compare Immediate                  result = reg2 - (sign extend imm5)
  011100   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">LDSR</a>    Load into System Register          regID = reg2
  010000   <a href="#cpuformatii">II</a>  <a href="#cpuregistertoregistertransfer">MOV</a>     Move Immediate                     reg2 = sign extend imm5
  011001   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">RETI</a>    Return from Trap/IRQ               (See section)
  010111   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SAR</a>     Shift Arithmetic Right Immediate   reg2 = reg2 >> (zero extend imm5) (sign-propagating)
  011110   <a href="#cpuformatii">II</a>  <a href="#cpunintendoinstructions">SEI</a>     Set interrupt disable flag         I = 1
  010010   <a href="#cpuformatii">II</a>  <a href="#cpumiscinstructions">SETF</a>    Set Flag Condition                 reg2 = 1 if condition true, 0 otherwise
  010100   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SHL</a>     Shift Left Immediate               reg2 = reg2 << (zero extend imm5)
  010101   <a href="#cpuformatii">II</a>  <a href="#cpubitwiseoperations">SHR</a>     Shift Right Immediate              reg2 = reg2 >> (zero extend imm5)
  011101   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">STSR</a>    Store from System Register         reg2 = regID
  011000   <a href="#cpuformatii">II</a>  <a href="#cpucpucontrol">TRAP</a>    Trap                               raise exception 0xFFA0 + vector
  011111   <a href="#cpuformatii">II</a>  *       (<a href="#cpubitstringinstructions">Bit string instructions</a>)          (See section)
  100     <a href="#cpuformatiii">III</a>  <a href="#cpuconditionalbranches">Bcond</a>   Conditional branches               (See section)
  101011   <a href="#cpuformativ">IV</a>  <a href="#cpunormaljumps">JAL</a>     Jump and Link                      r31 = PC + 4, PC = PC + disp26
  101010   <a href="#cpuformativ">IV</a>  <a href="#cpunormaljumps">JR</a>      Jump relative                      PC = PC + disp26
  101001    <a href="#cpuformatv">V</a>  <a href="#cpuarithmeticoperations">ADDI</a>    Add Immediate                      reg2 = reg1 + (sign extend imm16)
  101101    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">ANDI</a>    And Immediate                      reg2 = reg1 and (zero extend imm16)
  101000    <a href="#cpuformatv">V</a>  <a href="#cpuregistertoregistertransfer">MOVEA</a>   Add Immediate                      reg2 = reg1 + (sign extend imm16)
  101111    <a href="#cpuformatv">V</a>  <a href="#cpuregistertoregistertransfer">MOVHI</a>   Add High Halfword                  reg2 = reg1 + (imm16 << 16)
  101100    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">ORI</a>     OR Immediate                       reg2 = reg1 or (zero extended imm16)
  101110    <a href="#cpuformatv">V</a>  <a href="#cpubitwiseoperations">XORI</a>    Exclusive Or Immediate             reg2 = reg1 xor (zero extend imm16)
  111010   <a href="#cpuformatvi">VI</a>  <a href="#cpumiscinstructions">CAXI</a>    Compare and Exchange Interlocked   (See section)
  111000   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.B</a>    Input Byte                         reg2 = zero extend (byte ptr [reg1 + disp16])
  111001   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.H</a>    Input Halfword                     reg2 = zero extend (halfword ptr [reg1 + disp16])
  111011   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">IN.W</a>    Input Word                         reg2 = word ptr [reg1 + disp16]
  110000   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.B</a>    Load Byte                          reg2 = sign extend (byte ptr [reg1 + disp16])
  110001   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.H</a>    Load Halfword                      reg2 = sign extend (halfword ptr [reg1 + disp16])
  110011   <a href="#cpuformatvi">VI</a>  <a href="#cpuloadandinputregister">LD.W</a>    Load Word                          reg2 = word ptr [reg1 + disp16]
  111100   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.B</a>   Output Byte                        byte ptr [reg1 + disp16] = reg2 and 0xFF
  111101   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.H</a>   Output Halfword                    halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  111111   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">OUT.W</a>   Output Word                        word ptr [reg1 + disp16] = reg2
  110100   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.B</a>    Store Byte                         byte ptr [reg1 + disp16] = reg2 and 0xFF
  110101   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.H</a>    Store Halfword                     halfword ptr [reg1 + disp16] = reg2 and 0xFFFF
  110111   <a href="#cpuformatvi">VI</a>  <a href="#cpustoreandoutputregister">ST.W</a>    Store Word                         word ptr [reg1 + disp16] = reg2
  111110  <a href="#cpuformatvii">VII</a>  *       (<a href="#cpufloatingpointinstructions">Floating-point instructions</a>)      (See section)
</pre><br />



<h1><a name="systemreset">System Reset</a></h1>

The initial state of the Virtual Boy system upon system reset/power-on is as
follows.<br /><br />

<a name="resetmemory"><b>Memory</b></a><br /><br />

All memory in the Virtual Boy, including <a href="#cpumemorymap">WRAM</a>,
<a href="#virtualimageprocessorvip">VIP</a> memory and
<a href="#virtualsoundunitvsu">VSU</a> memory, are undefined at system startup.
The values in memory contain junk, and programs should not expect them to
contain any particular value.<br /><br />

<a name="resetcpuregisters"><b>CPU Registers</b></a><br /><br />

The <a href="#cpuregistersandflags">CPU registers</a> are initialized to the
following values:<br />

<pre class="indent">
r1-r31  Undefined
PC      0xFFFFFFF0
PSW     0x00008000
EIPC    Undefined
EIPSW   Undefined
FEPC    Undefined
FEPSW   Undefined
ECR     0x0000FFF0
</pre>

When <a href="#cpupswprogramstatusword">PSW</a> is initialized, the <i>NP</i>
flag is set. This must be reset manually using the
<a href="#cpucpucontrol"><i>LDSR</i></a> instruction. Otherwise, any
exceptions or interrupts that occur will result in an immediate
deadlock.<br /><br />

The exception code and initial address in <a href="#cpupcprogramcounter">PC</a>
point to the Reset interrupt handler. Do not use the
<a href="#cpucpucontrol"><i>RETI</i></a> instruction to return from the Reset
interrupt.<br /><br />

<a name="resetvipregisters"><b>VIP</b></a><br /><br />

The states of the <a href="#virtualimageprocessorvip">VIP</a> control registers
and their associated functionality on system reset are as follows. Any bits
marked as "not used" are treated as 0 in this list:<br />

<pre class="indent">
Interrupt Enable   0x0000
0x0005F800 - Interrupt Pending       Undefined
0x0005F802 - Interrupt Enable        0x0000
0x0005F820 - Display Status          See below
0x0005F824 - LED Brightness 1        Undefined
0x0005F826 - LED Brightness 2        Undefined
0x0005F828 - LED Brightness 3        Undefined
0x0005F82A - LED Brightness Idle     Undefined
0x0005F82E - Frame Repeat            Undefined
0x0005F840 - Drawing Status          See below
0x0005F848 - OBJ Group 0 Pointer     Undefined
0x0005F84A - OBJ Group 1 Pointer     Undefined
0x0005F84C - OBJ Group 2 Pointer     Undefined
0x0005F84E - OBJ Group 3 Pointer     Undefined
0x0005F860 - BG Palette 0            Undefined
0x0005F862 - BG Palette 1            Undefined
0x0005F864 - BG Palette 2            Undefined
0x0005F866 - BG Palette 3            Undefined
0x0005F868 - OBJ Palette 0           Undefined
0x0005F86A - OBJ Palette 1           Undefined
0x0005F86C - OBJ Palette 2           Undefined
0x0005F86E - OBJ Palette 3           Undefined
0x0005F870 - Clear Color             Undefined
</pre>

Some bits in <a href="#vipdisplayregisters">Display Status</a> are undefined
on system reset. The guaranteed values are as follows:<br />

<pre class="indent">
0 - Display Sync Signals Enabled
0 - VIP Memory is Refreshing
0 - Display Procedure Beginning
</pre>

Some bits in <a href="#vipdrawingregisters">Drawing Status</a> are undefined
as well. The guaranteed values are as follows:<br />

<pre class="indent">
0 - Drawing is Enabled
</pre>

<a name="resetvsuregisters"><b>VSU</b></a><br /><br />

<i>Editor's Note: Is any aspect of the VSU initialized? The sound channels all
appear to be stopped, but the Nintendo boilerplate assembly sets Sound Disable
before initializing static memory.</i><br /><br />

<span class="br"></span>

<a name="resethardwarecontrolregisters"><b>Hardware Control
Registers</b></a><br /><br />

The states of the <a href="#hardwarecontrolregisters">Hardware Control
Registers</a> and their associated functionality on system reset are as
follows. Any bits marked as "not used" are treated as 0 in this
list:<br />

<pre class="indent">
0x02000000 - Link Control Register             0x03
0x02000004 - Auxiliary Link Register           0x9F
0x02000008 - Link Transmit Data                0x00
0x0200000C - Link Receive Data                 0x00
0x02000010 - Game Pad Input Low                0x00
0x02000014 - Game Pad Input High               0x00
0x02000018 - Timer Counter/Reload Low          See below
0x0200001C - Timer Counter/Reload High         See below
0x02000020 - Timer Control Register            0x04
0x02000024 - Wait Control Register             0x00
0x02000028 - Game Pad Input Control Register   0x04
</pre>

The initial count value of the <a href="#hardwaretimer">timer</a> is 0xFFFF,
but its initial reload value is 0x0000.<br /><br />



<h1><a name="credits">About VB Sacred Tech Scroll</a></h1>

<b>VB Sacred Tech Scroll</b><br />
<div class="indent">
Version 0.91 (WIP) - January 4, 2013<br />
<div class="indent">
ROUGH DRAFT! It still needs some work, but I'm putting it out there so people
can get to it.
</div>
Written by Guy Perfect
</div><br />

Presentation and formatting largely inspired by the Nocash technical documents
by Martin Korth: <span class="mono"><a
href="http://nocash.emubase.de/">http://nocash.emubase.de/</a></span
><br /><br />

<b>Thanks & Credits</b><br /><br />

This document is a compilation of information published in other documents, but
is otherwise original work. The sources used for this document are as
follows:<br /><br />

<b>Planet Virtual Boy</b><br />
<div class="indent">
A community of people just like me. What more could you want?<br />
<span class="mono"><a
href="http://www.planetvb.com/">http://www.planetvb.com/</a></span><br />
Special thanks to these contributors in particular, in alphabetical
order:<br />
<div class="indent">
&bull; Benjamin Stevens - Testing support<br />
&bull; bigmak - Testing support<br />
&bull; dasi - Resources and testing support<br />
&bull; DogP - Unwitting source of information<br />
&bull; HorvatM - Resources and testing support<br />
</div>
</div><br />

<b>V810 Family&trade; 32-bit Microprocessor User's Manual</b><br />
<div class="indent">
Document No. U10082EJ1V0UM00 (1st edition) - October 1995<br />
Written by NEC
</div><br />

<b>Richard Hutchinson</b><br />
<div class="indent">
Created the FlashBoy Plus flash cartridge, which was invaluable for original
research.<br />
Those listed above for "testing support" ran my test code on their own FlashBoy
units when I didn't have one.
</div><br />

<b>Project: Virtual Boy</b><br />
<div class="indent">
Resource with various goods, including hardware specifics.<br />
<span class="mono"><a
href="http://www.projectvb.com/">http://www.projectvb.com/</a></span><br />
</div><br />

<b>Virtual Boy&trade; Programmers Manual</b><br />
<div class="indent">
Version 0.521 - January 2005<br />
Written by David Tucker, with thanks to the following contributors:<br />
<div class="indent">
Bob VanderClay, Ben Hanor, Alberto Covarrubias,<br />
Amos Bieler, Frostgiant, Parasyte, DogP
</div>
</div><br />

<b>Virtual Boy</b><br />
<div class="indent">
Article on Wikipedia.<br />
<span class="mono"><a href="http://en.wikipedia.org/wiki/Virtual_Boy"
>http://en.wikipedia.org/wiki/Virtual_Boy</a></span>
</div><br />

<h1>&nbsp;</h1>

  </body>
</html>